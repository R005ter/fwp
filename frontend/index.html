<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>ðŸŽ† Fireworks Show Planner</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* iOS Safari fixes */
    input[type="range"] {
      -webkit-appearance: none;
      touch-action: pan-y;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: #f97316;
      border-radius: 50%;
      cursor: pointer;
    }
    /* Prevent text selection on drag elements */
    .no-select {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
    /* Better touch targets */
    @media (max-width: 768px) {
      button, input, select {
        min-height: 44px; /* iOS recommended touch target */
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="module">
    import React from 'https://esm.sh/react@18';
    import ReactDOM from 'https://esm.sh/react-dom@18/client';
    
    // Use relative URL in production, localhost in development
    const API_BASE = window.location.hostname === 'localhost' 
      ? 'http://localhost:5000' 
      : window.location.origin;

    // ======================
    // Client-Side YouTube Downloader (Multiple Methods + IndexedDB)
    // ======================
    
    // Piped instances (more reliable alternative to Invidious)
    const PIPED_INSTANCES = [
      'https://pipedapi.kavin.rocks',
      'https://api-piped.mha.fi',
      'https://pipedapi.tokhmi.xyz',
      'https://piped-api.garudalinux.org',
      'https://pipedapi.osphost.fi'
    ];
    
    // Invidious instances (fallback)
    const INVIDIOUS_INSTANCES = [
      'https://invidious.flokinet.to',
      'https://invidious.io.lol',
      'https://invidious.osi.kr',
      'https://yewtu.be'
    ];
    
    // Extract YouTube video ID from URL
    function extractVideoId(url) {
      const patterns = [
        /[?&]v=([^&]+)/,
        /youtu\.be\/([^?&]+)/,
        /^([a-zA-Z0-9_-]{11})$/
      ];
      
      for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match) return match[1];
      }
      return null;
    }
    
    // IndexedDB utilities for storing videos
    const DB_NAME = 'FireworksVideos';
    const DB_VERSION = 1;
    const STORE_NAME = 'videos';
    
    async function openVideoDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            const store = db.createObjectStore(STORE_NAME, { keyPath: 'videoId' });
            store.createIndex('timestamp', 'timestamp', { unique: false });
          }
        };
      });
    }
    
    async function saveVideoToDB(videoId, blob, metadata = {}) {
      const db = await openVideoDB();
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        
        const request = store.put({
          videoId,
          blob,
          timestamp: Date.now(),
          ...metadata
        });
        
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
    
    async function getVideoFromDB(videoId) {
      const db = await openVideoDB();
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(videoId);
        
        request.onsuccess = () => {
          const result = request.result;
          if (result && result.blob) {
            resolve(URL.createObjectURL(result.blob));
          } else {
            resolve(null);
          }
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    async function getVideoMetadataFromDB(videoId) {
      const db = await openVideoDB();
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(videoId);
        
        request.onsuccess = () => {
          const result = request.result;
          if (result) {
            resolve({
              videoId: result.videoId,
              title: result.title,
              timestamp: result.timestamp,
              ...result
            });
          } else {
            resolve(null);
          }
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    // Download video via Piped API (preferred method)
    async function downloadViaPiped(videoId, onProgress) {
      console.log('[Piped] Starting download via Piped API for video:', videoId);
      console.log('[Piped] Available instances:', PIPED_INSTANCES.length);
      
      for (let i = 0; i < PIPED_INSTANCES.length; i++) {
        const instance = PIPED_INSTANCES[i];
        try {
          console.log(`[Piped] Attempt ${i + 1}/${PIPED_INSTANCES.length}: Trying instance ${instance}`);
          
          // Get video info
          const infoUrl = `${instance}/streams/${videoId}`;
          console.log('[Piped] Fetching video info from:', infoUrl);
          
          const infoResponse = await fetch(infoUrl, {
            headers: { 'Accept': 'application/json' }
          });
          
          console.log('[Piped] Info response status:', infoResponse.status, infoResponse.statusText);
          
          if (!infoResponse.ok) {
            const errorText = await infoResponse.text().catch(() => 'No error details');
            console.warn(`[Piped] Instance ${instance} returned ${infoResponse.status}:`, errorText);
            throw new Error(`HTTP ${infoResponse.status}: ${errorText.substring(0, 100)}`);
          }
          
          const videoInfo = await infoResponse.json();
          console.log('[Piped] Video info received:', {
            title: videoInfo.title,
            hasStreams: !!videoInfo.videoStreams,
            streamCount: videoInfo.videoStreams?.length || 0
          });
          
          if (!videoInfo.videoStreams || videoInfo.videoStreams.length === 0) {
            console.warn('[Piped] No video streams in response:', videoInfo);
            throw new Error('No video streams available');
          }
          
          // Find best quality video format
          const videoStreams = videoInfo.videoStreams.filter(s => 
            s.format === 'mp4' || s.format === 'webm'
          );
          
          console.log('[Piped] Filtered video streams:', {
            total: videoInfo.videoStreams.length,
            compatible: videoStreams.length,
            formats: videoStreams.map(s => ({ format: s.format, quality: s.quality }))
          });
          
          if (videoStreams.length === 0) {
            console.warn('[Piped] No compatible formats. Available formats:', 
              videoInfo.videoStreams.map(s => s.format).join(', '));
            throw new Error('No compatible video formats');
          }
          
          // Sort by quality (best first)
          videoStreams.sort((a, b) => {
            const aQuality = parseInt(a.quality?.replace('p', '') || '0', 10);
            const bQuality = parseInt(b.quality?.replace('p', '') || '0', 10);
            return bQuality - aQuality;
          });
          
          const bestStream = videoStreams[0];
          const videoUrl = bestStream.url;
          
          console.log('[Piped] Selected stream:', {
            quality: bestStream.quality,
            format: bestStream.format,
            urlLength: videoUrl?.length || 0,
            hasUrl: !!videoUrl
          });
          
          if (!videoUrl) {
            console.error('[Piped] Stream object:', bestStream);
            throw new Error('No video URL found in stream');
          }
          
          console.log(`[Piped] Starting download from: ${instance}`);
          console.log(`[Piped] Video URL: ${videoUrl.substring(0, 100)}...`);
          
          // Download the video with progress tracking
          console.log('[Piped] Fetching video file...');
          const videoResponse = await fetch(videoUrl);
          
          console.log('[Piped] Video response:', {
            status: videoResponse.status,
            statusText: videoResponse.statusText,
            contentType: videoResponse.headers.get('Content-Type'),
            contentLength: videoResponse.headers.get('Content-Length')
          });
          
          if (!videoResponse.ok) {
            const errorText = await videoResponse.text().catch(() => 'No error details');
            console.error(`[Piped] Download failed: HTTP ${videoResponse.status}`, errorText.substring(0, 200));
            throw new Error(`Download failed: HTTP ${videoResponse.status}`);
          }
          
          const contentLength = parseInt(videoResponse.headers.get('Content-Length') || '0', 10);
          console.log('[Piped] Content length:', contentLength, 'bytes');
          
          const reader = videoResponse.body.getReader();
          
          let receivedLength = 0;
          const chunks = [];
          let lastProgressLog = 0;
          
          console.log('[Piped] Starting to read video stream...');
          while (true) {
            const { done, value } = await reader.read();
            if (done) {
              console.log('[Piped] Stream reading complete. Total received:', receivedLength, 'bytes');
              break;
            }
            
            chunks.push(value);
            receivedLength += value.length;
            
            if (onProgress && contentLength > 0) {
              const percentage = (receivedLength / contentLength) * 100;
              
              // Log progress every 10%
              if (percentage - lastProgressLog >= 10) {
                console.log(`[Piped] Download progress: ${Math.round(percentage)}% (${receivedLength}/${contentLength} bytes)`);
                lastProgressLog = percentage;
              }
              
              onProgress({
                loaded: receivedLength,
                total: contentLength,
                percentage: Math.min(percentage, 100)
              });
            }
          }
          
          console.log('[Piped] Creating blob from chunks...');
          const blob = new Blob(chunks, { type: 'video/mp4' });
          console.log('[Piped] Blob created:', {
            size: blob.size,
            type: blob.type
          });
          
          // Save to IndexedDB
          console.log('[Piped] Saving to IndexedDB...');
          await saveVideoToDB(videoId, blob, {
            title: videoInfo.title || `Video ${videoId}`,
            duration: videoInfo.duration || 0,
            thumbnail: videoInfo.thumbnailUrl
          });
          console.log('[Piped] Saved to IndexedDB successfully');
          
          const localUrl = URL.createObjectURL(blob);
          console.log('[Piped] Download complete!', {
            videoId,
            title: videoInfo.title,
            blobSize: blob.size,
            instance
          });
          
          return {
            success: true,
            videoId,
            title: videoInfo.title || `Video ${videoId}`,
            blob,
            localUrl: localUrl,
            instance: `Piped (${instance})`
          };
          
        } catch (error) {
          console.warn(`[Piped] Instance ${instance} failed:`, {
            message: error.message,
            stack: error.stack,
            attempt: i + 1,
            total: PIPED_INSTANCES.length
          });
          continue;
        }
      }
      
      console.error('[Piped] All instances failed after trying', PIPED_INSTANCES.length, 'instances');
      throw new Error('All Piped instances failed');
    }
    
    // Download video via Invidious API (fallback)
    async function downloadViaInvidious(videoId, onProgress) {
      for (const instance of INVIDIOUS_INSTANCES) {
        try {
          console.log(`Trying Invidious instance: ${instance}`);
          
          const infoResponse = await fetch(`${instance}/api/v1/videos/${videoId}`, {
            headers: { 'Accept': 'application/json' }
          });
          
          if (!infoResponse.ok) {
            throw new Error(`HTTP ${infoResponse.status}`);
          }
          
          const videoInfo = await infoResponse.json();
          const formats = videoInfo.formatStreams || videoInfo.adaptiveFormats || [];
          const videoFormats = formats.filter(f => 
            f.type && (f.type.includes('video/mp4') || f.type.includes('video/webm'))
          );
          
          if (videoFormats.length === 0) {
            throw new Error('No video formats available');
          }
          
          videoFormats.sort((a, b) => {
            const aQuality = a.quality || a.bitrate || 0;
            const bQuality = b.quality || b.bitrate || 0;
            return bQuality - aQuality;
          });
          
          const bestFormat = videoFormats[0];
          const videoUrl = bestFormat.url || bestFormat.src;
          
          if (!videoUrl) {
            throw new Error('No video URL found');
          }
          
          console.log(`Downloading from Invidious: ${instance}`);
          
          const videoResponse = await fetch(videoUrl);
          if (!videoResponse.ok) {
            throw new Error(`Download failed: HTTP ${videoResponse.status}`);
          }
          
          const contentLength = parseInt(videoResponse.headers.get('Content-Length') || '0', 10);
          const reader = videoResponse.body.getReader();
          
          let receivedLength = 0;
          const chunks = [];
          
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            
            chunks.push(value);
            receivedLength += value.length;
            
            if (onProgress && contentLength > 0) {
              const percentage = (receivedLength / contentLength) * 100;
              onProgress({
                loaded: receivedLength,
                total: contentLength,
                percentage: Math.min(percentage, 100)
              });
            }
          }
          
          const blob = new Blob(chunks, { type: 'video/mp4' });
          
          await saveVideoToDB(videoId, blob, {
            title: videoInfo.title || `Video ${videoId}`,
            duration: videoInfo.lengthSeconds || 0,
            thumbnail: videoInfo.videoThumbnails?.[0]?.url
          });
          
          return {
            success: true,
            videoId,
            title: videoInfo.title || `Video ${videoId}`,
            blob,
            localUrl: URL.createObjectURL(blob),
            instance: `Invidious (${instance})`
          };
          
        } catch (error) {
          console.warn(`Invidious instance ${instance} failed:`, error.message);
          continue;
        }
      }
      
      throw new Error('All Invidious instances failed');
    }
    
    // Main client-side download function with multiple fallbacks
    async function downloadYouTubeVideoClient(url, onProgress) {
      console.log('[DownloadClient] Starting client-side download...', { url });
      
      const videoId = extractVideoId(url);
      console.log('[DownloadClient] Extracted video ID:', videoId);
      
      if (!videoId) {
        console.error('[DownloadClient] Invalid video ID extracted from URL:', url);
        throw new Error('Invalid YouTube URL');
      }
      
      // Check if already downloaded
      console.log('[DownloadClient] Checking cache...');
      const existing = await getVideoFromDB(videoId);
      if (existing) {
        console.log('[DownloadClient] Video found in cache, returning cached version');
        const metadata = await getVideoMetadataFromDB(videoId);
        return {
          success: true,
          videoId,
          title: metadata?.title || `Video ${videoId}`,
          localUrl: existing,
          cached: true
        };
      }
      
      console.log('[DownloadClient] Video not cached, starting download process...');
      
      // Try Piped first (most reliable)
      try {
        console.log('[DownloadClient] Attempting download via Piped API (primary method)...');
        const result = await downloadViaPiped(videoId, onProgress);
        console.log('[DownloadClient] Piped download successful!');
        return result;
      } catch (pipedError) {
        console.error('[DownloadClient] Piped download failed:', {
          message: pipedError.message,
          stack: pipedError.stack
        });
        console.log('[DownloadClient] Falling back to Invidious API...');
        
        // Fallback to Invidious
        try {
          const result = await downloadViaInvidious(videoId, onProgress);
          console.log('[DownloadClient] Invidious download successful!');
          return result;
        } catch (invidiousError) {
          console.error('[DownloadClient] Invidious download also failed:', {
            message: invidiousError.message,
            stack: invidiousError.stack
          });
          console.error('[DownloadClient] All client-side methods failed. Error summary:', {
            pipedError: pipedError.message,
            invidiousError: invidiousError.message,
            videoId: videoId
          });
          
          // Final fallback: server-side download (if available)
          throw new Error(`Client-side download failed. Piped: ${pipedError.message}. Invidious: ${invidiousError.message}`);
        }
      }
    }

    // ======================
    // Login/Register Component
    // ======================
    const LoginView = ({ onLogin }) => {
      const [isLogin, setIsLogin] = React.useState(true);
      const [username, setUsername] = React.useState('');
      const [email, setEmail] = React.useState('');
      const [password, setPassword] = React.useState('');
      const [error, setError] = React.useState('');
      const [loading, setLoading] = React.useState(false);

      // Check for OAuth errors in URL
      React.useEffect(() => {
        const hash = window.location.hash;
        const urlParams = new URLSearchParams(hash.split('?')[1] || '');
        const oauthError = urlParams.get('error');
        
        if (oauthError) {
          const errorMessages = {
            'oauth_not_configured': 'Google sign-in is not configured on the server.',
            'oauth_failed': 'Google sign-in failed. Please try again.',
            'user_creation_failed': 'Could not create account. Please try again.',
            'oauth_error': 'An error occurred during sign-in. Please try again.'
          };
          setError(errorMessages[oauthError] || 'Sign-in failed. Please try again.');
          // Clean up URL
          window.history.replaceState({}, document.title, window.location.pathname);
        }
      }, []);

      const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setLoading(true);

        try {
          const endpoint = isLogin ? '/api/auth/login' : '/api/auth/register';
          const body = isLogin 
            ? { username, password }
            : { username, email, password };

          const res = await fetch(`${API_BASE}${endpoint}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify(body)
          });

          const data = await res.json();

          if (res.ok && data.success) {
            onLogin(data.user);
          } else {
            setError(data.error || 'Something went wrong');
          }
        } catch (err) {
          setError('Connection error. Is the backend running?');
        } finally {
          setLoading(false);
        }
      };

      return React.createElement('div', { 
        className: 'min-h-screen bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900 flex items-center justify-center p-4' 
      },
        React.createElement('div', { 
          className: 'bg-gray-800/90 backdrop-blur rounded-lg p-8 w-full max-w-md border border-purple-500/30 shadow-xl' 
        },
          React.createElement('div', { className: 'text-center mb-8' },
            React.createElement('h1', { className: 'text-4xl font-bold text-orange-400 mb-2' }, 'ðŸŽ† Fireworks Planner'),
            React.createElement('p', { className: 'text-gray-300' }, 
              isLogin ? 'Sign in to access your shows' : 'Create an account to get started'
            )
          ),

          error && React.createElement('div', { 
            className: 'bg-red-900/50 border border-red-600 text-red-200 px-4 py-3 rounded mb-4 text-sm' 
          }, error),

          React.createElement('form', { onSubmit: handleSubmit, className: 'space-y-4' },
            React.createElement('div', null,
              React.createElement('label', { className: 'block text-sm text-gray-400 mb-2' }, 'Username'),
              React.createElement('input', {
                type: 'text',
                value: username,
                onChange: (e) => setUsername(e.target.value),
                required: true,
                minLength: 3,
                className: 'w-full bg-gray-700 text-white px-4 py-3 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-base',
                placeholder: 'Enter username',
                autoFocus: true
              })
            ),

            !isLogin && React.createElement('div', null,
              React.createElement('label', { className: 'block text-sm text-gray-400 mb-2' }, 'Email (optional)'),
              React.createElement('input', {
                type: 'email',
                value: email,
                onChange: (e) => setEmail(e.target.value),
                className: 'w-full bg-gray-700 text-white px-4 py-3 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-base',
                placeholder: 'your@email.com'
              })
            ),

            React.createElement('div', null,
              React.createElement('label', { className: 'block text-sm text-gray-400 mb-2' }, 'Password'),
              React.createElement('input', {
                type: 'password',
                value: password,
                onChange: (e) => setPassword(e.target.value),
                required: true,
                minLength: isLogin ? 1 : 6,
                className: 'w-full bg-gray-700 text-white px-4 py-3 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-base',
                placeholder: 'Enter password'
              })
            ),

            React.createElement('button', {
              type: 'submit',
              disabled: loading,
              className: `w-full bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 disabled:cursor-not-allowed px-4 py-3 rounded-lg font-bold text-base transition ${loading ? 'opacity-50' : ''}`
            }, loading ? 'Please wait...' : (isLogin ? 'Sign In' : 'Create Account')),

            React.createElement('div', { className: 'text-center pt-4' },
              React.createElement('button', {
                type: 'button',
                onClick: () => {
                  setIsLogin(!isLogin);
                  setError('');
                  setPassword('');
                },
                className: 'text-purple-400 hover:text-purple-300 text-sm underline'
              }, isLogin 
                ? "Don't have an account? Sign up" 
                : "Already have an account? Sign in"
              )
            )
          ),

          // Google OAuth Button
          React.createElement('div', { className: 'mt-6' },
            React.createElement('div', { className: 'flex items-center mb-4' },
              React.createElement('div', { className: 'flex-1 border-t border-gray-600' }),
              React.createElement('span', { className: 'px-4 text-sm text-gray-400' }, 'OR'),
              React.createElement('div', { className: 'flex-1 border-t border-gray-600' })
            ),
            React.createElement('button', {
              type: 'button',
              onClick: () => {
                // Pass the frontend URL so OAuth can redirect back to the correct port
                const frontendUrl = window.location.origin;
                window.location.href = `${API_BASE}/api/auth/google?frontend_url=${encodeURIComponent(frontendUrl)}`;
              },
              className: 'w-full bg-white hover:bg-gray-100 text-gray-800 px-4 py-3 rounded-lg font-medium text-base transition flex items-center justify-center gap-3 border border-gray-300'
            },
              React.createElement('svg', { 
                className: 'w-5 h-5',
                viewBox: '0 0 24 24'
              },
                React.createElement('path', {
                  fill: '#4285F4',
                  d: 'M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z'
                }),
                React.createElement('path', {
                  fill: '#34A853',
                  d: 'M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z'
                }),
                React.createElement('path', {
                  fill: '#FBBC05',
                  d: 'M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z'
                }),
                React.createElement('path', {
                  fill: '#EA4335',
                  d: 'M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z'
                })
              ),
              React.createElement('span', null, 'Sign in with Google')
            )
          )
        )
      );
    };

    // ======================
    // Dashboard Component
    // ======================
    const Dashboard = ({ 
      onEditShow, 
      onNewShow,
      onGoToLibrary,
      savedSessions, 
      onDeleteShow, 
      downloadedVideos,
      onDownloadComplete,
      currentUser,
      onLogout
    }) => {
      const [searchQuery, setSearchQuery] = React.useState('');
      const [youtubeSearchQuery, setYoutubeSearchQuery] = React.useState('');
      const [showYoutubePanel, setShowYoutubePanel] = React.useState(false);
      const [youtubeUrl, setYoutubeUrl] = React.useState('');
      const [downloading, setDownloading] = React.useState([]);
      const [backendStatus, setBackendStatus] = React.useState(null);

      React.useEffect(() => {
        fetch(`${API_BASE}/api/health`)
          .then(res => res.json())
          .then(data => setBackendStatus(data))
          .catch(() => setBackendStatus({ status: 'offline' }));
      }, []);

      React.useEffect(() => {
        if (downloading.length === 0) return;
        
        const interval = setInterval(async () => {
          const updates = await Promise.all(
            downloading.map(async (dl) => {
              try {
                const res = await fetch(`${API_BASE}/api/download/${dl.id}`, {
                  credentials: 'include'
                });
                const status = await res.json();
                return { ...dl, ...status };
              } catch {
                return dl;
              }
            })
          );
          
          setDownloading(updates.filter(dl => dl.status === 'downloading'));
          
          updates
            .filter(dl => dl.status === 'complete' && dl.filename)
            .forEach(dl => {
              onDownloadComplete(dl);
            });
        }, 1000);
        
        return () => clearInterval(interval);
      }, [downloading, onDownloadComplete]);

      const handleYoutubeDownload = async () => {
        console.log('[Download] Starting download process...', { url: youtubeUrl });
        
        if (!youtubeUrl.trim()) {
          console.warn('[Download] Empty URL provided');
          return;
        }
        
        const videoId = extractVideoId(youtubeUrl);
        console.log('[Download] Extracted video ID:', videoId);
        
        if (!videoId) {
          console.error('[Download] Invalid YouTube URL:', youtubeUrl);
          alert('Invalid YouTube URL. Please enter a valid YouTube video URL.');
          return;
        }
        
        // Check if already downloaded locally (IndexedDB)
        console.log('[Download] Checking IndexedDB for existing video...');
        const existing = await getVideoFromDB(videoId);
        if (existing) {
          console.log('[Download] Video found in local cache');
          const metadata = await getVideoMetadataFromDB(videoId);
          onDownloadComplete({
            id: videoId,
            videoId: videoId,
            filename: `${videoId}.mp4`,
            title: metadata?.title || `Video ${videoId}`,
            status: 'complete',
            localUrl: existing,
            cached: true
          });
          setYoutubeUrl('');
          return;
        }
        
        // Use yt-dlp directly (works reliably with proxy and cookies)
        console.log('[Download] Starting download via yt-dlp...');
        const downloadId = `dl_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        setDownloading(prev => [...prev, { 
          id: downloadId, 
          url: youtubeUrl,
          videoId: videoId,
          status: 'downloading',
          progress: 0,
          title: 'Starting download...',
          serverSide: true  // yt-dlp uses polling for progress
        }]);
        
        try {
          console.log('[Download] Calling yt-dlp endpoint...');
          const res = await fetch(`${API_BASE}/api/download`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ url: youtubeUrl })
          });
          
          const data = await res.json();
          console.log('[Download] yt-dlp response:', data);
          
          if (data.error) {
            console.error('[Download] Download failed:', data.error);
            alert(`Download failed: ${data.error}`);
            setDownloading(prev => prev.filter(dl => dl.id !== downloadId));
            return;
          }
          
          // Update with actual download ID for polling
          if (data.id && data.id !== downloadId) {
            setDownloading(prev => prev.map(dl => 
              dl.id === downloadId 
                ? { ...dl, id: data.id, status: 'downloading', serverSide: true }
                : dl
            ));
          }
          
          // If download completed immediately (unlikely but possible)
          if (data.status === 'complete') {
            console.log('[Download] Download complete!');
            setDownloading(prev => prev.filter(dl => dl.id !== downloadId));
            onDownloadComplete({
              id: downloadId,
              videoId: videoId,
              filename: data.filename,
              title: data.title,
              status: 'complete',
              localUrl: `${API_BASE}/videos/${data.filename}`
            });
            setYoutubeUrl('');
          }
          // Otherwise, polling will handle progress updates
        } catch (err) {
          console.error('[Download] Download failed:', err);
          alert(`Download failed: ${err.message}\n\nPlease check your connection and try again.`);
          setDownloading(prev => prev.filter(dl => dl.id !== downloadId));
        }
      };

      const filteredSessions = savedSessions.filter(s => 
        s.name.toLowerCase().includes(searchQuery.toLowerCase())
      );

      const sortedSessions = [...filteredSessions].sort((a, b) => 
        new Date(b.timestamp) - new Date(a.timestamp)
      );

      return React.createElement('div', { className: 'min-h-screen bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900 text-white p-6' },
        React.createElement('div', { className: 'max-w-7xl mx-auto' },
          // Header
          React.createElement('div', { className: 'flex flex-col md:flex-row items-start md:items-center justify-between mb-6 md:mb-8 gap-4' },
            React.createElement('div', null,
              React.createElement('h1', { className: 'text-3xl md:text-4xl font-bold text-orange-400 mb-2' }, 'ðŸŽ† Fireworks Show Planner'),
              React.createElement('p', { className: 'text-sm md:text-base text-gray-300' }, 
                currentUser ? `Welcome, ${currentUser.username}!` : 'Plan your perfect fireworks show'
              )
            ),
            React.createElement('div', { className: 'flex flex-col sm:flex-row gap-2 w-full md:w-auto' },
              React.createElement('button', {
                onClick: onGoToLibrary,
                className: 'bg-green-500 hover:bg-green-600 px-6 py-3 rounded-lg font-bold text-base md:text-lg transition shadow-lg'
              }, 'ðŸ“š Library'),
              React.createElement('button', {
                onClick: onNewShow,
                className: 'bg-orange-500 hover:bg-orange-600 px-6 py-3 rounded-lg font-bold text-base md:text-lg transition shadow-lg'
              }, '+ New Show'),
              React.createElement('button', {
                onClick: onLogout,
                className: 'bg-gray-600 hover:bg-gray-700 px-4 py-3 rounded-lg font-medium text-sm md:text-base transition'
              }, 'ðŸšª Logout')
            )
          ),

          // Stats Bar
          React.createElement('div', { className: 'grid grid-cols-3 gap-2 md:gap-4 mb-6 md:mb-8' },
            React.createElement('div', { 
              className: 'bg-gray-800/50 backdrop-blur rounded-lg p-4 border border-purple-500/30 cursor-pointer hover:border-purple-400 transition',
              onClick: () => sortedSessions.length > 0 && onEditShow(sortedSessions[0].name)
            },
              React.createElement('div', { className: 'text-3xl font-bold text-purple-400' }, savedSessions.length),
              React.createElement('div', { className: 'text-sm text-gray-400 mt-1' }, 'Total Shows')
            ),
            React.createElement('div', { 
              className: 'bg-gray-800/50 backdrop-blur rounded-lg p-4 border border-blue-500/30 cursor-pointer hover:border-blue-400 transition',
              onClick: onGoToLibrary
            },
              React.createElement('div', { className: 'text-3xl font-bold text-blue-400' }, downloadedVideos.size),
              React.createElement('div', { className: 'text-sm text-gray-400 mt-1' }, 'Videos in Library')
            ),
            React.createElement('div', { className: 'bg-gray-800/50 backdrop-blur rounded-lg p-4 border border-green-500/30' },
              React.createElement('div', { className: 'text-3xl font-bold ' + (backendStatus?.status === 'ok' ? 'text-green-400' : 'text-red-400') }, 
                backendStatus?.status === 'ok' ? 'â—' : 'â—‹'
              ),
              React.createElement('div', { className: 'text-sm text-gray-400 mt-1' }, 
                backendStatus?.status === 'ok' ? 'Backend Connected' : 'Backend Offline'
              )
            )
          ),

          // Main Content Grid
          React.createElement('div', { className: 'grid grid-cols-1 lg:grid-cols-3 gap-4 md:gap-6' },
            // Left Side: Shows List (2/3 width on large screens)
            React.createElement('div', { className: 'lg:col-span-2' },
              React.createElement('div', { className: 'bg-gray-800/50 backdrop-blur rounded-lg p-6 border border-purple-500/30' },
                React.createElement('div', { className: 'flex items-center justify-between mb-4' },
                  React.createElement('h2', { className: 'text-2xl font-bold text-purple-300' }, 'ðŸŽ­ Your Shows'),
                  React.createElement('input', {
                    type: 'text',
                    value: searchQuery,
                    onChange: (e) => setSearchQuery(e.target.value),
                    placeholder: 'Search shows...',
                    className: 'bg-gray-700/50 text-white px-4 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 w-64'
                  })
                ),

                sortedSessions.length === 0 
                  ? React.createElement('div', { className: 'text-center py-12' },
                      React.createElement('div', { className: 'text-6xl mb-4' }, 'ðŸŽ†'),
                      React.createElement('p', { className: 'text-xl text-gray-400 mb-2' }, 'No shows yet'),
                      React.createElement('p', { className: 'text-sm text-gray-500 mb-6' }, 'Create your first fireworks show to get started!'),
                      React.createElement('button', {
                        onClick: onNewShow,
                        className: 'bg-orange-500 hover:bg-orange-600 px-6 py-3 rounded-lg font-bold transition'
                      }, '+ Create First Show')
                    )
                  : React.createElement('div', { className: 'space-y-3 max-h-[600px] overflow-y-auto' },
                      sortedSessions.map(session => 
                        React.createElement('div', {
                          key: session.name,
                          className: 'bg-gray-700/50 rounded-lg p-4 hover:bg-gray-700 transition cursor-pointer border border-transparent hover:border-purple-500',
                          onClick: () => onEditShow(session.name)
                        },
                          React.createElement('div', { className: 'flex items-start justify-between' },
                            React.createElement('div', { className: 'flex-1' },
                              React.createElement('div', { className: 'flex items-center gap-3 mb-2' },
                                React.createElement('h3', { className: 'text-xl font-bold text-white' }, session.name),
                                React.createElement('span', { className: 'text-xs px-2 py-1 bg-purple-600 rounded' }, 
                                  `${session.videos.length} items`
                                )
                              ),
                              React.createElement('div', { className: 'text-sm text-gray-400 mb-2' },
                                `Duration: ${session.totalDuration?.toFixed(0) || 60}s`
                              ),
                              React.createElement('div', { className: 'text-xs text-gray-500' },
                                `Last modified: ${new Date(session.timestamp).toLocaleDateString()} at ${new Date(session.timestamp).toLocaleTimeString()}`
                              )
                            ),
                            React.createElement('div', { className: 'flex gap-2', onClick: (e) => e.stopPropagation() },
                              React.createElement('button', {
                                onClick: () => onEditShow(session.name),
                                className: 'bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded text-sm transition'
                              }, 'âœï¸ Edit'),
                              React.createElement('button', {
                                onClick: () => {
                                  if (confirm(`Delete show "${session.name}"?`)) {
                                    onDeleteShow(session.name);
                                  }
                                },
                                className: 'bg-red-600 hover:bg-red-700 px-3 py-1 rounded text-sm transition'
                              }, 'ðŸ—‘ï¸')
                            )
                          )
                        )
                      )
                    )
              )
            ),

            // Right Side: YouTube Downloader
            React.createElement('div', { className: 'space-y-6' },
              React.createElement('div', { className: 'bg-gray-800/50 backdrop-blur rounded-lg p-6 border border-orange-500/30' },
                React.createElement('h2', { className: 'text-xl font-bold text-orange-300 mb-4' }, 'ðŸ“¥ YouTube Downloader'),
                React.createElement('div', { className: 'text-xs text-blue-400 flex items-center gap-2 mb-3' },
                  React.createElement('span', { className: 'w-2 h-2 bg-blue-400 rounded-full' }),
                  'Client-side download â€¢ No server required'
                ),
                
                React.createElement('div', { className: 'space-y-3' },
                  React.createElement('input', {
                    type: 'text',
                    value: youtubeUrl,
                    onChange: (e) => setYoutubeUrl(e.target.value),
                    placeholder: 'Paste YouTube URL...',
                    className: 'w-full bg-gray-700/50 text-white px-3 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500',
                    onKeyDown: (e) => e.key === 'Enter' && handleYoutubeDownload()
                  }),
                  React.createElement('button', {
                    onClick: handleYoutubeDownload,
                    disabled: !youtubeUrl.trim(),
                    className: 'w-full bg-orange-600 hover:bg-orange-700 disabled:bg-gray-600 disabled:cursor-not-allowed px-4 py-2 rounded-lg transition font-bold'
                  }, 'Download Video'),

                  downloading.length > 0 && React.createElement('div', { className: 'space-y-2 mt-3' },
                    downloading.map(dl => 
                      React.createElement('div', { key: dl.id, className: 'bg-gray-700/50 rounded p-2' },
                        React.createElement('div', { className: 'flex justify-between text-xs mb-1' },
                          React.createElement('span', { className: 'truncate' }, dl.title || 'Downloading...'),
                          React.createElement('span', null, `${Math.round(dl.progress || 0)}%`)
                        ),
                        React.createElement('div', { className: 'h-2 bg-gray-600 rounded overflow-hidden' },
                          React.createElement('div', {
                            className: 'h-full bg-orange-500 transition-all',
                            style: { width: `${dl.progress || 0}%` }
                          })
                        )
                      )
                    )
                  ),

                  React.createElement('div', { className: 'pt-3 border-t border-gray-700' },
                    React.createElement('button', {
                      onClick: () => setShowYoutubePanel(!showYoutubePanel),
                      className: 'text-sm text-blue-400 hover:text-blue-300 underline'
                    }, showYoutubePanel ? 'â†‘ Hide YouTube Search' : 'ðŸ” Search YouTube')
                  ),

                  showYoutubePanel && React.createElement('div', { className: 'bg-gray-900/50 rounded-lg p-3 border border-blue-500/30' },
                    React.createElement('p', { className: 'text-xs text-gray-400 mb-2' }, 'Search YouTube in new tab:'),
                    React.createElement('input', {
                      type: 'text',
                      value: youtubeSearchQuery,
                      onChange: (e) => setYoutubeSearchQuery(e.target.value),
                      placeholder: 'e.g., fireworks display...',
                      className: 'w-full bg-gray-700/50 text-white px-3 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm mb-2',
                      onKeyDown: (e) => {
                        if (e.key === 'Enter' && youtubeSearchQuery.trim()) {
                          window.open(`https://www.youtube.com/results?search_query=${encodeURIComponent(youtubeSearchQuery)}`, '_blank');
                        }
                      }
                    }),
                    React.createElement('button', {
                      onClick: () => {
                        if (youtubeSearchQuery.trim()) {
                          window.open(`https://www.youtube.com/results?search_query=${encodeURIComponent(youtubeSearchQuery)}`, '_blank');
                        }
                      },
                      className: 'w-full bg-blue-600 hover:bg-blue-700 px-3 py-2 rounded-lg text-sm transition'
                    }, 'ðŸ” Search on YouTube')
                  )
                )
              ),

              // Quick Library Preview
              React.createElement('div', { 
                className: 'bg-gray-800/50 backdrop-blur rounded-lg p-6 border border-green-500/30 cursor-pointer hover:border-green-400 transition',
                onClick: onGoToLibrary
              },
                React.createElement('div', { className: 'flex items-center justify-between mb-3' },
                  React.createElement('h2', { className: 'text-xl font-bold text-green-300' }, 'ðŸ“š Library'),
                  React.createElement('span', { className: 'text-sm text-gray-400' }, `${downloadedVideos.size} videos`)
                ),
                React.createElement('p', { className: 'text-sm text-gray-400 mb-3' }, 'Manage your video collection'),
                React.createElement('button', {
                  className: 'w-full bg-green-600 hover:bg-green-700 px-4 py-2 rounded-lg transition'
                }, 'Manage Library â†’')
              )
            )
          )
        )
      );
    };

    // ======================
    // Library Management Component
    // ======================
    const LibraryView = ({ 
      downloadedVideos,
      setDownloadedVideos,
      onBack, 
      onEditVideo, 
      onDeleteVideo,
      onSaveVideoSettings,
      onDownloadComplete
    }) => {
      const [searchQuery, setSearchQuery] = React.useState('');
      const [editingVideo, setEditingVideo] = React.useState(null);
      const [previewVideoRef, setPreviewVideoRef] = React.useState(null);
      const [previewTime, setPreviewTime] = React.useState(0);
      const [previewPlaying, setPreviewPlaying] = React.useState(false);
      const [editTitle, setEditTitle] = React.useState('');
      const [editTrimStart, setEditTrimStart] = React.useState(0);
      const [editTrimEnd, setEditTrimEnd] = React.useState(0);
      
      // Crop settings (as percentages: 0-100)
      const [editCropX, setEditCropX] = React.useState(0);
      const [editCropY, setEditCropY] = React.useState(0);
      const [editCropWidth, setEditCropWidth] = React.useState(100);
      const [editCropHeight, setEditCropHeight] = React.useState(100);
      
      // YouTube download functionality
      const [youtubeUrl, setYoutubeUrl] = React.useState('');
      const [downloading, setDownloading] = React.useState([]);
      const [backendStatus, setBackendStatus] = React.useState(null);
      const [youtubeSearchQuery, setYoutubeSearchQuery] = React.useState('');
      const [showYoutubePanel, setShowYoutubePanel] = React.useState(false);
      
      // Detect mobile device (hide YouTube downloads on mobile)
      const [isMobile, setIsMobile] = React.useState(false);
      React.useEffect(() => {
        const checkMobile = () => {
          const isMobileDevice = window.innerWidth < 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
          setIsMobile(isMobileDevice);
        };
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
      }, []);

      React.useEffect(() => {
        fetch(`${API_BASE}/api/health`)
          .then(res => res.json())
          .then(data => setBackendStatus(data))
          .catch(() => setBackendStatus({ status: 'offline' }));
      }, []);

      // Poll for download progress (only for server-side downloads)
      React.useEffect(() => {
        if (downloading.length === 0) return;
        
        // Filter to only server-side downloads (client-side handles its own progress)
        const serverDownloads = downloading.filter(dl => dl.serverSide === true);
        if (serverDownloads.length === 0) {
          console.log('[Polling] No server-side downloads to poll');
          return;
        }
        
        console.log(`[Polling] Starting to poll ${serverDownloads.length} server-side download(s)...`);
        
        const interval = setInterval(async () => {
          const updates = await Promise.all(
            serverDownloads.map(async (dl) => {
              try {
                console.log(`[Polling] Checking status for download: ${dl.id}`);
                const res = await fetch(`${API_BASE}/api/download/${dl.id}`, {
                  credentials: 'include'
                });
                
                if (!res.ok) {
                  console.warn(`[Polling] Status check failed for ${dl.id}: HTTP ${res.status}`);
                  return dl;
                }
                
                const status = await res.json();
                console.log(`[Polling] Status for ${dl.id}:`, {
                  status: status.status,
                  progress: status.progress,
                  title: status.title
                });
                
                return { ...dl, ...status };
              } catch (err) {
                console.error(`[Polling] Error checking status for ${dl.id}:`, err);
                return dl;
              }
            })
          );
          
          // Update only server-side downloads, keep client-side downloads as-is
          setDownloading(prev => {
            const clientDownloads = prev.filter(dl => !dl.serverSide);
            const updatedServerDownloads = updates.filter(dl => dl.status === 'downloading');
            return [...clientDownloads, ...updatedServerDownloads];
          });
          
          // Notify parent of completed downloads
          updates
            .filter(dl => dl.status === 'complete' && dl.filename)
            .forEach(dl => {
              console.log(`[Polling] Download complete: ${dl.id} - ${dl.title || dl.filename}`);
              onDownloadComplete(dl);
            });
        }, 1000);
        
        return () => {
          console.log('[Polling] Stopping polling');
          clearInterval(interval);
        };
      }, [downloading, onDownloadComplete]);

      const handleYoutubeDownload = async () => {
        console.log('[Download] Starting download process...', { url: youtubeUrl });
        
        if (!youtubeUrl.trim()) {
          console.warn('[Download] Empty URL provided');
          return;
        }
        
        const videoId = extractVideoId(youtubeUrl);
        console.log('[Download] Extracted video ID:', videoId);
        
        if (!videoId) {
          console.error('[Download] Invalid YouTube URL:', youtubeUrl);
          alert('Invalid YouTube URL. Please enter a valid YouTube video URL.');
          return;
        }
        
        // Check if already downloaded locally (IndexedDB)
        console.log('[Download] Checking IndexedDB for existing video...');
        const existing = await getVideoFromDB(videoId);
        if (existing) {
          console.log('[Download] Video found in local cache');
          const metadata = await getVideoMetadataFromDB(videoId);
          onDownloadComplete({
            id: videoId,
            videoId: videoId,
            filename: `${videoId}.mp4`,
            title: metadata?.title || `Video ${videoId}`,
            status: 'complete',
            localUrl: existing,
            cached: true
          });
          setYoutubeUrl('');
          return;
        }
        
        // Use yt-dlp directly (works reliably with proxy and cookies)
        console.log('[Download] Starting download via yt-dlp...');
        const downloadId = `dl_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        setDownloading(prev => [...prev, { 
          id: downloadId, 
          url: youtubeUrl,
          videoId: videoId,
          status: 'downloading',
          progress: 0,
          title: 'Starting download...',
          serverSide: true  // yt-dlp uses polling for progress
        }]);
        
        try {
          console.log('[Download] Calling yt-dlp endpoint...');
          const res = await fetch(`${API_BASE}/api/download`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ url: youtubeUrl })
          });
          
          const data = await res.json();
          console.log('[Download] yt-dlp response:', data);
          
          if (data.error) {
            console.error('[Download] Download failed:', data.error);
            alert(`Download failed: ${data.error}`);
            setDownloading(prev => prev.filter(dl => dl.id !== downloadId));
            return;
          }
          
          // Update with actual download ID for polling
          if (data.id && data.id !== downloadId) {
            setDownloading(prev => prev.map(dl => 
              dl.id === downloadId 
                ? { ...dl, id: data.id, status: 'downloading', serverSide: true }
                : dl
            ));
          }
          
          // If download completed immediately (unlikely but possible)
          if (data.status === 'complete') {
            console.log('[Download] Download complete!');
            setDownloading(prev => prev.filter(dl => dl.id !== downloadId));
            onDownloadComplete({
              id: downloadId,
              videoId: videoId,
              filename: data.filename,
              title: data.title,
              status: 'complete',
              localUrl: `${API_BASE}/videos/${data.filename}`
            });
            setYoutubeUrl('');
          }
          // Otherwise, polling will handle progress updates
        } catch (err) {
          console.error('[Download] Download failed:', err);
          alert(`Download failed: ${err.message}\n\nPlease check your connection and try again.`);
          setDownloading(prev => prev.filter(dl => dl.id !== downloadId));
        }
      };

      const filteredVideos = Array.from(downloadedVideos.values()).filter(v =>
        v.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
        v.filename.toLowerCase().includes(searchQuery.toLowerCase())
      );

      const handleEditVideo = (video) => {
        setEditingVideo(video);
        setEditTitle(video.title);
        setEditTrimStart(video.defaultTrimStart || 0);
        setEditTrimEnd(video.defaultTrimEnd || 0);
        setEditCropX(video.defaultCropX || 0);
        setEditCropY(video.defaultCropY || 0);
        setEditCropWidth(video.defaultCropWidth || 100);
        setEditCropHeight(video.defaultCropHeight || 100);
        setPreviewTime(video.defaultTrimStart || 0);
        setPreviewPlaying(false);
      };

      const handleSaveVideo = () => {
        if (editingVideo) {
          onSaveVideoSettings(editingVideo.filename, {
            title: editTitle,
            defaultTrimStart: editTrimStart,
            defaultTrimEnd: editTrimEnd,
            defaultCropX: editCropX,
            defaultCropY: editCropY,
            defaultCropWidth: editCropWidth,
            defaultCropHeight: editCropHeight
          });
          if (previewVideoRef) {
            previewVideoRef.pause();
          }
          setEditingVideo(null);
        }
      };

      const handleCancelEdit = () => {
        if (previewVideoRef) {
          previewVideoRef.pause();
        }
        setEditingVideo(null);
      };

      return React.createElement('div', { className: 'min-h-screen bg-gradient-to-br from-gray-900 via-green-900 to-gray-900 text-white p-6' },
        React.createElement('div', { className: 'max-w-7xl mx-auto' },
          // Header
          React.createElement('div', { className: 'flex items-center justify-between mb-8' },
            React.createElement('div', null,
              React.createElement('div', { className: 'flex items-center gap-4' },
                React.createElement('button', {
                  onClick: onBack,
                  className: 'bg-gray-700 hover:bg-gray-600 px-4 py-2 rounded-lg transition'
                }, 'â† Back'),
                React.createElement('div', null,
                  React.createElement('h1', { className: 'text-4xl font-bold text-green-400 mb-2' }, 'ðŸ“š Video Library'),
                  React.createElement('p', { className: 'text-gray-300' }, 'Manage your fireworks video collection')
                )
              )
            ),
            React.createElement('div', { className: 'text-right' },
              React.createElement('div', { className: 'text-2xl font-bold text-green-400' }, downloadedVideos.size),
              React.createElement('div', { className: 'text-sm text-gray-400' }, 'Total Videos')
            )
          ),

          !editingVideo ? (
            // Video List View
            React.createElement('div', null,
              // YouTube Downloader Section (hidden on mobile)
              !isMobile && React.createElement('div', { className: 'bg-gray-800/50 backdrop-blur rounded-lg p-6 border border-orange-500/30 mb-6' },
                React.createElement('h2', { className: 'text-xl font-bold text-orange-300 mb-4' }, 'ðŸ“¥ Add Videos to Library'),
                React.createElement('div', { className: 'text-xs text-blue-400 flex items-center gap-2 mb-3' },
                  React.createElement('span', { className: 'w-2 h-2 bg-blue-400 rounded-full' }),
                  'Client-side download â€¢ No server required'
                ),
                
                React.createElement('div', { className: 'space-y-3' },
                  React.createElement('div', { className: 'flex gap-2' },
                    React.createElement('input', {
                      type: 'text',
                      value: youtubeUrl,
                      onChange: (e) => setYoutubeUrl(e.target.value),
                      placeholder: 'Paste YouTube URL...',
                      className: 'flex-1 bg-gray-700/50 text-white px-3 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500',
                      onKeyDown: (e) => e.key === 'Enter' && handleYoutubeDownload()
                    }),
                    React.createElement('button', {
                      onClick: handleYoutubeDownload,
                      disabled: !youtubeUrl.trim(),
                      className: 'bg-orange-600 hover:bg-orange-700 disabled:bg-gray-600 disabled:cursor-not-allowed px-6 py-2 rounded-lg transition font-bold'
                    }, 'Download')
                  ),

                  downloading.length > 0 && React.createElement('div', { className: 'space-y-2' },
                    downloading.map(dl => 
                      React.createElement('div', { key: dl.id, className: 'bg-gray-700/50 rounded p-2' },
                        React.createElement('div', { className: 'flex justify-between text-xs mb-1' },
                          React.createElement('span', { className: 'truncate' }, dl.title || 'Downloading...'),
                          React.createElement('span', null, `${Math.round(dl.progress || 0)}%`)
                        ),
                        React.createElement('div', { className: 'h-2 bg-gray-600 rounded overflow-hidden' },
                          React.createElement('div', {
                            className: 'h-full bg-orange-500 transition-all',
                            style: { width: `${dl.progress || 0}%` }
                          })
                        )
                      )
                    )
                  ),

                  React.createElement('div', { className: 'pt-3 border-t border-gray-700' },
                    React.createElement('button', {
                      onClick: () => setShowYoutubePanel(!showYoutubePanel),
                      className: 'text-sm text-blue-400 hover:text-blue-300 underline'
                    }, showYoutubePanel ? 'â†‘ Hide YouTube Search' : 'ðŸ” Search YouTube')
                  ),

                  showYoutubePanel && React.createElement('div', { className: 'bg-gray-900/50 rounded-lg p-3 border border-blue-500/30' },
                    React.createElement('p', { className: 'text-xs text-gray-400 mb-2' }, 'Search YouTube in new tab:'),
                    React.createElement('input', {
                      type: 'text',
                      value: youtubeSearchQuery,
                      onChange: (e) => setYoutubeSearchQuery(e.target.value),
                      placeholder: 'e.g., fireworks display...',
                      className: 'w-full bg-gray-700/50 text-white px-3 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm mb-2',
                      onKeyDown: (e) => {
                        if (e.key === 'Enter' && youtubeSearchQuery.trim()) {
                          window.open(`https://www.youtube.com/results?search_query=${encodeURIComponent(youtubeSearchQuery)}`, '_blank');
                        }
                      }
                    }),
                    React.createElement('button', {
                      onClick: () => {
                        if (youtubeSearchQuery.trim()) {
                          window.open(`https://www.youtube.com/results?search_query=${encodeURIComponent(youtubeSearchQuery)}`, '_blank');
                        }
                      },
                      className: 'w-full bg-blue-600 hover:bg-blue-700 px-3 py-2 rounded-lg text-sm transition'
                    }, 'ðŸ” Search on YouTube')
                  )
                )
              ),

              // Search Bar
              React.createElement('div', { className: 'bg-gray-800/50 backdrop-blur rounded-lg p-6 border border-green-500/30 mb-6' },
                React.createElement('input', {
                  type: 'text',
                  value: searchQuery,
                  onChange: (e) => setSearchQuery(e.target.value),
                  placeholder: 'Search videos...',
                  className: 'w-full bg-gray-700/50 text-white px-4 py-3 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500'
                })
              ),

              downloadedVideos.size === 0 
                ? React.createElement('div', { className: 'text-center py-20 bg-gray-800/50 backdrop-blur rounded-lg border border-green-500/30' },
                    React.createElement('div', { className: 'text-6xl mb-4' }, 'ðŸ“¹'),
                    React.createElement('p', { className: 'text-xl text-gray-400 mb-2' }, 'No videos in library'),
                    React.createElement('p', { className: 'text-sm text-gray-500' }, 'Download videos from YouTube to get started')
                  )
                : React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4' },
                    filteredVideos.map(video =>
                      React.createElement('div', {
                        key: video.filename,
                        className: 'bg-gray-800/50 backdrop-blur rounded-lg p-4 border border-green-500/30 hover:border-green-400 transition'
                      },
                        React.createElement('div', { className: 'mb-3' },
                          React.createElement('div', { className: 'font-bold text-lg mb-2 text-white truncate' }, video.title),
                          React.createElement('div', { className: 'text-xs text-gray-400 mb-2 truncate' }, video.filename),
                          
                          // Duration info
                          video.duration && React.createElement('div', { className: 'text-sm text-blue-400 mb-2 flex items-center gap-1' },
                            React.createElement('span', null, 'â±ï¸'),
                            React.createElement('span', null, (() => {
                              const trimmedDuration = (video.duration || 0) - (video.defaultTrimStart || 0) - (video.defaultTrimEnd || 0);
                              return `${trimmedDuration.toFixed(1)}s`;
                            })()),
                            (video.defaultTrimStart > 0 || video.defaultTrimEnd > 0) && React.createElement('span', { className: 'text-gray-500 text-xs' }, 
                              `(${video.duration?.toFixed(1)}s full)`
                            )
                          ),
                          
                          (video.defaultTrimStart > 0 || video.defaultTrimEnd > 0) && React.createElement('div', { className: 'text-xs text-yellow-400 mt-2 flex items-center gap-1' },
                            React.createElement('span', null, 'âœ‚ï¸'),
                            React.createElement('span', null, `Trim: ${video.defaultTrimStart.toFixed(1)}s - ${video.defaultTrimEnd.toFixed(1)}s`)
                          ),
                          
                          // Hidden video element to load duration
                          !video.duration && React.createElement('video', {
                            src: video.url,
                            style: { display: 'none' },
                            onLoadedMetadata: (e) => {
                              const duration = e.target.duration;
                              setDownloadedVideos(prev => {
                                const newMap = new Map(prev);
                                const existing = newMap.get(video.filename);
                                if (existing) {
                                  newMap.set(video.filename, { ...existing, duration });
                                  // Save to localStorage
                                  const libraryData = JSON.parse(localStorage.getItem('fwp_library') || '{}');
                                  libraryData[video.filename] = {
                                    ...libraryData[video.filename],
                                    duration
                                  };
                                  localStorage.setItem('fwp_library', JSON.stringify(libraryData));
                                }
                                return newMap;
                              });
                            }
                          })
                        ),
                        React.createElement('div', { className: 'flex gap-2' },
                          React.createElement('button', {
                            onClick: () => handleEditVideo(video),
                            className: 'flex-1 bg-blue-600 hover:bg-blue-700 px-3 py-2 rounded text-sm transition'
                          }, 'âœï¸ Edit'),
                          React.createElement('button', {
                            onClick: () => {
                              if (confirm(`Delete "${video.title}" from library?\n\nThis will remove it from the server and all shows.`)) {
                                onDeleteVideo(video);
                              }
                            },
                            className: 'bg-red-600 hover:bg-red-700 px-3 py-2 rounded text-sm transition'
                          }, 'ðŸ—‘ï¸')
                        )
                      )
                    )
                  )
            )
          ) : (
            // Video Editor View
            React.createElement('div', { className: 'bg-gray-800/50 backdrop-blur rounded-lg p-6 border border-blue-500/30' },
              React.createElement('div', { className: 'mb-6' },
                React.createElement('h2', { className: 'text-2xl font-bold text-blue-400 mb-2' }, 'Editing Video Settings'),
                React.createElement('div', { className: 'bg-yellow-900/30 border border-yellow-600/50 rounded-lg p-4 text-sm' },
                  React.createElement('div', { className: 'font-bold text-yellow-400 mb-2 flex items-center gap-2' },
                    React.createElement('span', null, 'âš ï¸'),
                    React.createElement('span', null, 'Important: Default Settings')
                  ),
                  React.createElement('p', { className: 'text-yellow-200 mb-2' }, 
                    'These are DEFAULT settings for new uses of this video.'
                  ),
                  React.createElement('p', { className: 'text-yellow-300' }, 
                    'Videos already added to shows will keep their existing settings and timing. This prevents accidental timing changes in your saved shows.'
                  )
                )
              ),

              React.createElement('div', { className: 'grid grid-cols-1 lg:grid-cols-2 gap-6' },
                // Left: Video Preview
                React.createElement('div', null,
                  React.createElement('h3', { className: 'text-lg font-semibold mb-3 text-gray-300' }, 'Preview'),
                  React.createElement('div', { 
                    className: 'relative bg-black rounded-lg mb-3 overflow-hidden',
                    style: { aspectRatio: '16/9' }
                  },
                    React.createElement('video', {
                      ref: el => setPreviewVideoRef(el),
                      src: editingVideo.url,
                      className: 'absolute inset-0 w-full h-full object-cover',
                      style: {
                        clipPath: `inset(${editCropY}% ${100 - editCropX - editCropWidth}% ${100 - editCropY - editCropHeight}% ${editCropX}%)`
                      },
                      onTimeUpdate: (e) => setPreviewTime(e.target.currentTime),
                      onLoadedMetadata: (e) => {
                        e.target.currentTime = editTrimStart;
                      }
                    })
                  ),
                  React.createElement('div', { className: 'flex gap-2 mb-3' },
                    React.createElement('button', {
                      onClick: () => {
                        if (previewVideoRef) {
                          if (previewPlaying) {
                            previewVideoRef.pause();
                            setPreviewPlaying(false);
                          } else {
                            previewVideoRef.play();
                            setPreviewPlaying(true);
                          }
                        }
                      },
                      className: 'flex-1 bg-green-600 hover:bg-green-700 py-2 rounded transition'
                    }, previewPlaying ? 'â¸ Pause' : 'â–¶ Play'),
                    React.createElement('button', {
                      onClick: () => {
                        if (previewVideoRef) {
                          previewVideoRef.currentTime = editTrimStart;
                        }
                      },
                      className: 'bg-gray-600 hover:bg-gray-500 py-2 px-4 rounded transition'
                    }, 'â†» Go to Start')
                  ),
                  
                  // Playback Slider
                  previewVideoRef && React.createElement('div', { className: 'mb-3' },
                    React.createElement('input', {
                      type: 'range',
                      min: '0',
                      max: previewVideoRef.duration || 0,
                      step: '0.1',
                      value: previewTime,
                      onChange: (e) => {
                        const newTime = parseFloat(e.target.value);
                        setPreviewTime(newTime);
                        if (previewVideoRef) {
                          previewVideoRef.currentTime = newTime;
                        }
                      },
                      className: 'w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500'
                    }),
                    React.createElement('div', { className: 'flex justify-between text-xs text-gray-500 mt-1' },
                      React.createElement('span', null, `0:00`),
                      React.createElement('span', null, previewVideoRef.duration ? `${Math.floor(previewVideoRef.duration / 60)}:${Math.floor(previewVideoRef.duration % 60).toString().padStart(2, '0')}` : '0:00')
                    )
                  ),
                  
                  React.createElement('div', { className: 'text-center text-sm text-gray-400' },
                    `Current Time: ${previewTime.toFixed(2)}s`,
                    previewVideoRef && ` / ${previewVideoRef.duration?.toFixed(2) || 0}s`
                  )
                ),

                // Right: Settings
                React.createElement('div', null,
                  React.createElement('h3', { className: 'text-lg font-semibold mb-3 text-gray-300' }, 'Default Settings'),
                  
                  React.createElement('div', { className: 'mb-4' },
                    React.createElement('label', { className: 'block text-sm text-gray-400 mb-2' }, 'Video Title:'),
                    React.createElement('input', {
                      type: 'text',
                      value: editTitle,
                      onChange: (e) => setEditTitle(e.target.value),
                      className: 'w-full bg-gray-700 text-white px-3 py-2 rounded focus:outline-none focus:ring-2 focus:ring-blue-500',
                      autoFocus: true
                    })
                  ),

                  React.createElement('div', { className: 'mb-4' },
                    React.createElement('label', { className: 'block text-sm text-gray-400 mb-2' }, 'Default Trim Start (seconds):'),
                    React.createElement('div', { className: 'flex gap-2' },
                      React.createElement('input', {
                        type: 'number',
                        value: editTrimStart,
                        onChange: (e) => {
                          const val = parseFloat(e.target.value) || 0;
                          setEditTrimStart(val);
                          if (previewVideoRef) {
                            previewVideoRef.currentTime = val;
                          }
                        },
                        step: '0.1',
                        min: '0',
                        className: 'flex-1 bg-gray-700 text-white px-3 py-2 rounded focus:outline-none focus:ring-2 focus:ring-blue-500'
                      }),
                      React.createElement('button', {
                        onClick: () => {
                          if (previewVideoRef) {
                            setEditTrimStart(parseFloat(previewTime.toFixed(2)));
                          }
                        },
                        className: 'bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded transition text-sm whitespace-nowrap'
                      }, 'â†“ Use Current Time')
                    ),
                    React.createElement('p', { className: 'text-xs text-gray-500 mt-1' }, 'Trim this many seconds from the beginning')
                  ),

                  React.createElement('div', { className: 'mb-6' },
                    React.createElement('label', { className: 'block text-sm text-gray-400 mb-2' }, 'Default Trim End (seconds):'),
                    React.createElement('div', { className: 'flex gap-2' },
                      React.createElement('input', {
                        type: 'number',
                        value: editTrimEnd,
                        onChange: (e) => {
                          const val = parseFloat(e.target.value) || 0;
                          setEditTrimEnd(val);
                          if (previewVideoRef) {
                            const duration = previewVideoRef.duration;
                            previewVideoRef.currentTime = duration - val;
                          }
                        },
                        step: '0.1',
                        min: '0',
                        className: 'flex-1 bg-gray-700 text-white px-3 py-2 rounded focus:outline-none focus:ring-2 focus:ring-blue-500'
                      }),
                      React.createElement('button', {
                        onClick: () => {
                          if (previewVideoRef) {
                            const duration = previewVideoRef.duration;
                            const trimEnd = duration - previewTime;
                            setEditTrimEnd(parseFloat(Math.max(0, trimEnd).toFixed(2)));
                          }
                        },
                        className: 'bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded transition text-sm whitespace-nowrap'
                      }, 'â†“ Use Current Time')
                    ),
                    React.createElement('p', { className: 'text-xs text-gray-500 mt-1' }, 'Trim this many seconds from the end')
                  ),

                  // Crop/Region Selection Section
                  React.createElement('div', { className: 'mb-6 pt-6 border-t border-gray-700' },
                    React.createElement('h4', { className: 'text-md font-semibold mb-3 text-gray-300' }, 'âœ‚ï¸ Crop/Region Selection'),
                    React.createElement('p', { className: 'text-xs text-gray-400 mb-3' }, 
                      'Perfect for split-screen or quad-view videos! Select just the cake you want.'
                    ),
                    
                    // Preset Buttons
                    React.createElement('div', { className: 'mb-3' },
                      React.createElement('label', { className: 'block text-sm text-gray-400 mb-2' }, 'Quick Presets:'),
                      React.createElement('div', { className: 'grid grid-cols-3 gap-2 mb-2' },
                        // Quad view presets
                        React.createElement('button', {
                          onClick: () => { setEditCropX(0); setEditCropY(0); setEditCropWidth(50); setEditCropHeight(50); },
                          className: 'bg-purple-600 hover:bg-purple-700 px-3 py-2 rounded text-xs transition'
                        }, 'â†– Top Left'),
                        React.createElement('button', {
                          onClick: () => { setEditCropX(50); setEditCropY(0); setEditCropWidth(50); setEditCropHeight(50); },
                          className: 'bg-purple-600 hover:bg-purple-700 px-3 py-2 rounded text-xs transition'
                        }, 'â†— Top Right'),
                        React.createElement('button', {
                          onClick: () => { setEditCropX(0); setEditCropY(0); setEditCropWidth(100); setEditCropHeight(50); },
                          className: 'bg-purple-600 hover:bg-purple-700 px-3 py-2 rounded text-xs transition'
                        }, 'â¬† Top Half'),
                        React.createElement('button', {
                          onClick: () => { setEditCropX(0); setEditCropY(50); setEditCropWidth(50); setEditCropHeight(50); },
                          className: 'bg-purple-600 hover:bg-purple-700 px-3 py-2 rounded text-xs transition'
                        }, 'â†™ Bottom Left'),
                        React.createElement('button', {
                          onClick: () => { setEditCropX(50); setEditCropY(50); setEditCropWidth(50); setEditCropHeight(50); },
                          className: 'bg-purple-600 hover:bg-purple-700 px-3 py-2 rounded text-xs transition'
                        }, 'â†˜ Bottom Right'),
                        React.createElement('button', {
                          onClick: () => { setEditCropX(0); setEditCropY(50); setEditCropWidth(100); setEditCropHeight(50); },
                          className: 'bg-purple-600 hover:bg-purple-700 px-3 py-2 rounded text-xs transition'
                        }, 'â¬‡ Bottom Half')
                      ),
                      React.createElement('div', { className: 'grid grid-cols-3 gap-2' },
                        React.createElement('button', {
                          onClick: () => { setEditCropX(0); setEditCropY(0); setEditCropWidth(50); setEditCropHeight(100); },
                          className: 'bg-purple-600 hover:bg-purple-700 px-3 py-2 rounded text-xs transition'
                        }, 'â† Left Half'),
                        React.createElement('button', {
                          onClick: () => { setEditCropX(50); setEditCropY(0); setEditCropWidth(50); setEditCropHeight(100); },
                          className: 'bg-purple-600 hover:bg-purple-700 px-3 py-2 rounded text-xs transition'
                        }, 'Right Half â†’'),
                        React.createElement('button', {
                          onClick: () => { setEditCropX(0); setEditCropY(0); setEditCropWidth(100); setEditCropHeight(100); },
                          className: 'bg-gray-600 hover:bg-gray-500 px-3 py-2 rounded text-xs transition'
                        }, 'âŠ¡ Full Frame')
                      )
                    ),

                    // Manual Controls
                    React.createElement('div', { className: 'space-y-3' },
                      React.createElement('label', { className: 'block text-sm text-gray-400 mb-2' }, 'Fine-tune (% of frame):'),
                      React.createElement('div', { className: 'grid grid-cols-2 gap-3' },
                        React.createElement('div', null,
                          React.createElement('label', { className: 'block text-xs text-gray-500 mb-1' }, 'X Position:'),
                          React.createElement('input', {
                            type: 'number',
                            value: editCropX,
                            onChange: (e) => setEditCropX(Math.max(0, Math.min(100, parseFloat(e.target.value) || 0))),
                            step: '1',
                            min: '0',
                            max: '100',
                            className: 'w-full bg-gray-700 text-white px-2 py-1 rounded text-sm focus:outline-none focus:ring-2 focus:ring-purple-500'
                          })
                        ),
                        React.createElement('div', null,
                          React.createElement('label', { className: 'block text-xs text-gray-500 mb-1' }, 'Y Position:'),
                          React.createElement('input', {
                            type: 'number',
                            value: editCropY,
                            onChange: (e) => setEditCropY(Math.max(0, Math.min(100, parseFloat(e.target.value) || 0))),
                            step: '1',
                            min: '0',
                            max: '100',
                            className: 'w-full bg-gray-700 text-white px-2 py-1 rounded text-sm focus:outline-none focus:ring-2 focus:ring-purple-500'
                          })
                        ),
                        React.createElement('div', null,
                          React.createElement('label', { className: 'block text-xs text-gray-500 mb-1' }, 'Width:'),
                          React.createElement('input', {
                            type: 'number',
                            value: editCropWidth,
                            onChange: (e) => setEditCropWidth(Math.max(1, Math.min(100, parseFloat(e.target.value) || 100))),
                            step: '1',
                            min: '1',
                            max: '100',
                            className: 'w-full bg-gray-700 text-white px-2 py-1 rounded text-sm focus:outline-none focus:ring-2 focus:ring-purple-500'
                          })
                        ),
                        React.createElement('div', null,
                          React.createElement('label', { className: 'block text-xs text-gray-500 mb-1' }, 'Height:'),
                          React.createElement('input', {
                            type: 'number',
                            value: editCropHeight,
                            onChange: (e) => setEditCropHeight(Math.max(1, Math.min(100, parseFloat(e.target.value) || 100))),
                            step: '1',
                            min: '1',
                            max: '100',
                            className: 'w-full bg-gray-700 text-white px-2 py-1 rounded text-sm focus:outline-none focus:ring-2 focus:ring-purple-500'
                          })
                        )
                      )
                    )
                  ),

                  React.createElement('div', { className: 'text-sm text-gray-400 bg-gray-900/50 rounded p-3 mb-6' },
                    previewVideoRef && React.createElement('div', null,
                      React.createElement('div', null, `Total Duration: ${previewVideoRef.duration?.toFixed(2) || 0}s`),
                      React.createElement('div', { className: 'text-green-400 font-bold' }, 
                        `Trimmed Duration: ${((previewVideoRef.duration || 0) - editTrimStart - editTrimEnd).toFixed(2)}s`
                      )
                    )
                  ),

                  React.createElement('div', { className: 'flex gap-3' },
                    React.createElement('button', {
                      onClick: handleSaveVideo,
                      className: 'flex-1 bg-green-600 hover:bg-green-700 px-4 py-3 rounded-lg transition font-bold'
                    }, 'âœ“ Save Changes'),
                    React.createElement('button', {
                      onClick: handleCancelEdit,
                      className: 'flex-1 bg-gray-600 hover:bg-gray-500 px-4 py-3 rounded-lg transition font-bold'
                    }, 'âœ• Cancel')
                  )
                )
              )
            )
          )
        )
      );
    };

    // ========================
    // Show Editor Component
    // ========================
    const ShowEditor = ({ 
      showName,
      videos,
      setVideos,
      downloadedVideos,
      isPlaying,
      setIsPlaying,
      masterTime,
      setMasterTime,
      totalDuration,
      setTotalDuration,
      zoom,
      setZoom,
      draggingId,
      setDraggingId,
      dragStartX,
      setDragStartX,
      dragStartOffset,
      setDragStartOffset,
      gridHeight,
      setGridHeight,
      videoRefs,
      timelineRef,
      onSave,
      onBack,
      onAddFromLibrary,
      onDownloadComplete
    }) => {
      const [saveAsName, setSaveAsName] = React.useState('');
      const [showSaveAs, setShowSaveAs] = React.useState(false);
      const [showLibraryAdd, setShowLibraryAdd] = React.useState(false);
      
      // YouTube download functionality
      const [showYoutubeDownload, setShowYoutubeDownload] = React.useState(false);
      const [youtubeUrl, setYoutubeUrl] = React.useState('');
      const [downloading, setDownloading] = React.useState([]);
      const [backendStatus, setBackendStatus] = React.useState(null);
      const [youtubeSearchQuery, setYoutubeSearchQuery] = React.useState('');
      const [showYoutubePanel, setShowYoutubePanel] = React.useState(false);
      
      // Detect mobile device (hide YouTube downloads on mobile)
      const [isMobile, setIsMobile] = React.useState(false);
      React.useEffect(() => {
        const checkMobile = () => {
          const isMobileDevice = window.innerWidth < 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
          setIsMobile(isMobileDevice);
        };
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
      }, []);

      React.useEffect(() => {
        fetch(`${API_BASE}/api/health`)
          .then(res => res.json())
          .then(data => setBackendStatus(data))
          .catch(() => setBackendStatus({ status: 'offline' }));
      }, []);

      // Poll for download progress (only for server-side downloads)
      React.useEffect(() => {
        if (downloading.length === 0) return;
        
        // Filter to only server-side downloads (client-side handles its own progress)
        const serverDownloads = downloading.filter(dl => dl.serverSide === true);
        if (serverDownloads.length === 0) {
          console.log('[Polling] No server-side downloads to poll');
          return;
        }
        
        console.log(`[Polling] Starting to poll ${serverDownloads.length} server-side download(s)...`);
        
        const interval = setInterval(async () => {
          const updates = await Promise.all(
            serverDownloads.map(async (dl) => {
              try {
                console.log(`[Polling] Checking status for download: ${dl.id}`);
                const res = await fetch(`${API_BASE}/api/download/${dl.id}`, {
                  credentials: 'include'
                });
                
                if (!res.ok) {
                  console.warn(`[Polling] Status check failed for ${dl.id}: HTTP ${res.status}`);
                  return dl;
                }
                
                const status = await res.json();
                console.log(`[Polling] Status for ${dl.id}:`, {
                  status: status.status,
                  progress: status.progress,
                  title: status.title
                });
                
                return { ...dl, ...status };
              } catch (err) {
                console.error(`[Polling] Error checking status for ${dl.id}:`, err);
                return dl;
              }
            })
          );
          
          // Update only server-side downloads, keep client-side downloads as-is
          setDownloading(prev => {
            const clientDownloads = prev.filter(dl => !dl.serverSide);
            const updatedServerDownloads = updates.filter(dl => dl.status === 'downloading');
            return [...clientDownloads, ...updatedServerDownloads];
          });
          
          // Notify parent of completed downloads
          updates
            .filter(dl => dl.status === 'complete' && dl.filename)
            .forEach(dl => {
              console.log(`[Polling] Download complete: ${dl.id} - ${dl.title || dl.filename}`);
              onDownloadComplete(dl);
            });
        }, 1000);
        
        return () => {
          console.log('[Polling] Stopping polling');
          clearInterval(interval);
        };
      }, [downloading, onDownloadComplete]);

      const handleYoutubeDownload = async () => {
        console.log('[Download] Starting download process...', { url: youtubeUrl });
        
        if (!youtubeUrl.trim()) {
          console.warn('[Download] Empty URL provided');
          return;
        }
        
        const videoId = extractVideoId(youtubeUrl);
        console.log('[Download] Extracted video ID:', videoId);
        
        if (!videoId) {
          console.error('[Download] Invalid YouTube URL:', youtubeUrl);
          alert('Invalid YouTube URL. Please enter a valid YouTube video URL.');
          return;
        }
        
        // Check if already downloaded locally (IndexedDB)
        console.log('[Download] Checking IndexedDB for existing video...');
        const existing = await getVideoFromDB(videoId);
        if (existing) {
          console.log('[Download] Video found in local cache');
          const metadata = await getVideoMetadataFromDB(videoId);
          onDownloadComplete({
            id: videoId,
            videoId: videoId,
            filename: `${videoId}.mp4`,
            title: metadata?.title || `Video ${videoId}`,
            status: 'complete',
            localUrl: existing,
            cached: true
          });
          setYoutubeUrl('');
          return;
        }
        
        // Use yt-dlp directly (works reliably with proxy and cookies)
        console.log('[Download] Starting download via yt-dlp...');
        const downloadId = `dl_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        setDownloading(prev => [...prev, { 
          id: downloadId, 
          url: youtubeUrl,
          videoId: videoId,
          status: 'downloading',
          progress: 0,
          title: 'Starting download...',
          serverSide: true  // yt-dlp uses polling for progress
        }]);
        
        try {
          console.log('[Download] Calling yt-dlp endpoint...');
          const res = await fetch(`${API_BASE}/api/download`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ url: youtubeUrl })
          });
          
          const data = await res.json();
          console.log('[Download] yt-dlp response:', data);
          
          if (data.error) {
            console.error('[Download] Download failed:', data.error);
            alert(`Download failed: ${data.error}`);
            setDownloading(prev => prev.filter(dl => dl.id !== downloadId));
            return;
          }
          
          // Update with actual download ID for polling
          if (data.id && data.id !== downloadId) {
            setDownloading(prev => prev.map(dl => 
              dl.id === downloadId 
                ? { ...dl, id: data.id, status: 'downloading', serverSide: true }
                : dl
            ));
          }
          
          // If download completed immediately (unlikely but possible)
          if (data.status === 'complete') {
            console.log('[Download] Download complete!');
            setDownloading(prev => prev.filter(dl => dl.id !== downloadId));
            onDownloadComplete({
              id: downloadId,
              videoId: videoId,
              filename: data.filename,
              title: data.title,
              status: 'complete',
              localUrl: `${API_BASE}/videos/${data.filename}`
            });
            setYoutubeUrl('');
          }
          // Otherwise, polling will handle progress updates
        } catch (err) {
          console.error('[Download] Download failed:', err);
          alert(`Download failed: ${err.message}\n\nPlease check your connection and try again.`);
          setDownloading(prev => prev.filter(dl => dl.id !== downloadId));
        }
      };

      const handleVideoLoaded = (id, duration) => {
        setVideos(prev => {
          const updated = prev.map(v => v.id === id ? { ...v, duration } : v);
          const maxEnd = Math.max(...updated.map(v => {
            const trimStart = v.trimStart || 0;
            const trimEnd = v.trimEnd || 0;
            return v.offset + (v.duration - trimStart - trimEnd);
          }));
          if (maxEnd > totalDuration) setTotalDuration(maxEnd + 10);
          return updated;
        });
      };

      const getEventX = (e) => {
        return e.touches ? e.touches[0].clientX : e.clientX;
      };

      const handleTimelineMouseDown = (e, videoId) => {
        e.stopPropagation();
        e.preventDefault();
        const video = videos.find(v => v.id === videoId);
        setDraggingId(videoId);
        setDragStartX(getEventX(e));
        setDragStartOffset(video.offset);
      };

      const handleTimelineMove = React.useCallback((e) => {
        if (!draggingId || !timelineRef.current) return;
        e.preventDefault();
        
        const timelineWidth = timelineRef.current.offsetWidth;
        const pixelsPerSecond = (timelineWidth * zoom) / totalDuration;
        const deltaX = getEventX(e) - dragStartX;
        const deltaTime = deltaX / pixelsPerSecond;
        const newOffset = Math.max(0, dragStartOffset + deltaTime);
        
        setVideos(prev => prev.map(v => 
          v.id === draggingId ? { ...v, offset: newOffset } : v
        ));
      }, [draggingId, dragStartX, dragStartOffset, zoom, totalDuration, setVideos, timelineRef]);

      const handleTimelineUp = React.useCallback((e) => {
        e.preventDefault();
        setDraggingId(null);
      }, [setDraggingId]);

      React.useEffect(() => {
        if (draggingId) {
          window.addEventListener('mousemove', handleTimelineMove);
          window.addEventListener('mouseup', handleTimelineUp);
          window.addEventListener('touchmove', handleTimelineMove, { passive: false });
          window.addEventListener('touchend', handleTimelineUp, { passive: false });
          return () => {
            window.removeEventListener('mousemove', handleTimelineMove);
            window.removeEventListener('mouseup', handleTimelineUp);
            window.removeEventListener('touchmove', handleTimelineMove);
            window.removeEventListener('touchend', handleTimelineUp);
          };
        }
      }, [draggingId, handleTimelineMove, handleTimelineUp]);

      const handleTimelineClick = (e) => {
        if (draggingId) return;
        const rect = timelineRef.current.getBoundingClientRect();
        const x = getEventX(e) - rect.left;
        const clickTime = (x / rect.width) * totalDuration / zoom;
        setMasterTime(Math.max(0, Math.min(clickTime, totalDuration)));
      };

      const removeVideo = (id) => {
        const video = videos.find(v => v.id === id);
        if (video?.url?.startsWith('blob:')) URL.revokeObjectURL(video.url);
        setVideos(prev => prev.filter(v => v.id !== id));
      };

      const updateOffset = (id, newOffset) => {
        setVideos(prev => prev.map(v => 
          v.id === id ? { ...v, offset: Math.max(0, parseFloat(newOffset) || 0) } : v
        ));
      };

      const updateTrimStart = (id, newTrimStart) => {
        setVideos(prev => prev.map(v => {
          if (v.id !== id) return v;
          const trimEnd = v.trimEnd || 0;
          const trimStart = Math.max(0, Math.min(parseFloat(newTrimStart) || 0, v.duration - trimEnd - 0.1));
          return { ...v, trimStart };
        }));
      };

      const updateTrimEnd = (id, newTrimEnd) => {
        setVideos(prev => prev.map(v => {
          if (v.id !== id) return v;
          const trimStart = v.trimStart || 0;
          const trimEnd = Math.max(0, Math.min(parseFloat(newTrimEnd) || 0, v.duration - trimStart - 0.1));
          return { ...v, trimEnd };
        }));
      };

      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        const ms = Math.floor((seconds % 1) * 10);
        return `${mins}:${secs.toString().padStart(2, '0')}.${ms}`;
      };

      const handleSave = () => {
        if (showName) {
          onSave(showName);
        } else {
          setShowSaveAs(true);
        }
      };

      const handleSaveAs = () => {
        if (saveAsName.trim()) {
          onSave(saveAsName.trim());
          setSaveAsName('');
          setShowSaveAs(false);
        }
      };

      // Detect mobile and portrait mode
      const [isPortrait, setIsPortrait] = React.useState(false);
      React.useEffect(() => {
        const checkOrientation = () => {
          setIsPortrait(window.innerHeight > window.innerWidth && window.innerWidth < 768);
        };
        checkOrientation();
        window.addEventListener('resize', checkOrientation);
        window.addEventListener('orientationchange', checkOrientation);
        return () => {
          window.removeEventListener('resize', checkOrientation);
          window.removeEventListener('orientationchange', checkOrientation);
        };
      }, []);

      // Compute filtered videos (only active ones) before rendering
      let filteredVideos = [];
      let activeVideos = [];
      
      try {
        filteredVideos = videos.length === 0 ? [] : videos.filter(video => {
          try {
            // If duration is 0 or not set, show the video (it's still loading)
            if (!video.duration || video.duration === 0) {
              return true;
            }
            
            const trimStart = video.trimStart || 0;
            const trimEnd = video.trimEnd || 0;
            const videoTime = (masterTime || 0) - (video.offset || 0);
            const trimmedDuration = (video.duration || 0) - trimStart - trimEnd;
            
            // Show if currently playing (within trimmed duration)
            return videoTime >= 0 && videoTime <= trimmedDuration;
          } catch (err) {
            console.error('Error filtering video:', video, err);
            return false;
          }
        });

        // Count active videos for header
        activeVideos = videos.filter(video => {
          try {
            if (!video.duration || video.duration === 0) return false;
            const trimStart = video.trimStart || 0;
            const trimEnd = video.trimEnd || 0;
            const videoTime = (masterTime || 0) - (video.offset || 0);
            const trimmedDuration = (video.duration || 0) - trimStart - trimEnd;
            return videoTime >= 0 && videoTime <= trimmedDuration;
          } catch (err) {
            return false;
          }
        });
      } catch (err) {
        console.error('Error computing filtered videos:', err);
        filteredVideos = videos || [];
        activeVideos = [];
      }

      try {
        return React.createElement('div', { className: 'min-h-screen bg-gray-900 text-white p-2 md:p-4 flex flex-col' },
        // Portrait mode warning
        isPortrait && React.createElement('div', { className: 'bg-yellow-600 text-yellow-100 px-4 py-3 mb-4 rounded-lg text-sm text-center' },
          'ðŸ“± Tip: Rotate to landscape for the best editing experience!'
        ),
        // Header
        React.createElement('div', { className: 'flex flex-col md:flex-row items-start md:items-center justify-between mb-4 gap-2' },
          React.createElement('div', { className: 'flex flex-col md:flex-row items-start md:items-center gap-2 md:gap-4' },
            React.createElement('button', {
              onClick: onBack,
              className: 'bg-gray-700 hover:bg-gray-600 px-4 py-3 md:py-2 rounded transition text-base md:text-sm'
            }, 'â† Back to Dashboard'),
            React.createElement('div', null,
              React.createElement('h1', { className: 'text-xl md:text-2xl font-bold text-orange-400' }, 
                showName ? `Editing: ${showName}` : 'New Show'
              )
            )
          ),
          React.createElement('div', { className: 'flex flex-wrap gap-2' },
            // YouTube download button (hidden on mobile)
            !isMobile && React.createElement('button', {
              onClick: () => setShowYoutubeDownload(!showYoutubeDownload),
              className: `px-4 py-3 md:py-2 rounded transition text-base md:text-sm ${showYoutubeDownload ? 'bg-orange-600 border-2 border-orange-400' : 'bg-orange-500 hover:bg-orange-600'}`
            }, 'ðŸ“¥ YouTube'),
            React.createElement('button', {
              onClick: () => setShowLibraryAdd(!showLibraryAdd),
              className: 'bg-green-600 hover:bg-green-700 px-4 py-3 md:py-2 rounded transition text-base md:text-sm'
            }, '+ Add from Library'),
            showName
              ? React.createElement('button', {
                  onClick: handleSave,
                  className: 'bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded transition font-bold'
                }, 'ðŸ’¾ Save')
              : React.createElement('button', {
                  onClick: () => setShowSaveAs(true),
                  className: 'bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded transition font-bold'
                }, 'ðŸ’¾ Save As...')
          )
        ),

        // Save As Dialog
        showSaveAs && React.createElement('div', { className: 'fixed inset-0 bg-black/50 flex items-center justify-center z-50' },
          React.createElement('div', { className: 'bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4' },
            React.createElement('h3', { className: 'text-xl font-bold mb-4' }, 'Save Show As'),
            React.createElement('input', {
              type: 'text',
              value: saveAsName,
              onChange: (e) => setSaveAsName(e.target.value),
              placeholder: 'Enter show name...',
              className: 'w-full bg-gray-700 text-white px-3 py-2 rounded focus:outline-none focus:ring-2 focus:ring-purple-500 mb-4',
              onKeyDown: (e) => e.key === 'Enter' && handleSaveAs(),
              autoFocus: true
            }),
            React.createElement('div', { className: 'flex gap-2' },
              React.createElement('button', {
                onClick: handleSaveAs,
                disabled: !saveAsName.trim(),
                className: 'flex-1 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 px-4 py-2 rounded transition'
              }, 'Save'),
              React.createElement('button', {
                onClick: () => { setShowSaveAs(false); setSaveAsName(''); },
                className: 'flex-1 bg-gray-600 hover:bg-gray-500 px-4 py-2 rounded transition'
              }, 'Cancel')
            )
          )
        ),

        // YouTube Download Panel (hidden on mobile)
        showYoutubeDownload && !isMobile && React.createElement('div', { className: 'fixed inset-0 bg-black/50 flex items-center justify-center z-50' },
          React.createElement('div', { className: 'bg-gray-800 rounded-lg p-6 max-w-2xl w-full mx-4' },
            React.createElement('div', { className: 'flex items-center justify-between mb-4' },
              React.createElement('h3', { className: 'text-xl font-bold text-orange-300' }, 'ðŸ“¥ Download from YouTube'),
              React.createElement('button', {
                onClick: () => setShowYoutubeDownload(false),
                className: 'bg-gray-600 hover:bg-gray-500 px-3 py-1 rounded'
              }, 'âœ•')
            ),
            
            backendStatus?.status === 'ok' 
              ? React.createElement('div', { className: 'text-xs text-green-400 flex items-center gap-2 mb-3' },
                  React.createElement('span', { className: 'w-2 h-2 bg-green-400 rounded-full' }),
                  `Connected â€¢ yt-dlp ${backendStatus.ytdlp_version}`
                )
              : React.createElement('div', { className: 'text-xs text-red-400 flex items-center gap-2 mb-3' },
                  React.createElement('span', { className: 'w-2 h-2 bg-red-400 rounded-full' }),
                  'Backend offline - start server.py'
                ),
            
            React.createElement('div', { className: 'space-y-3' },
              React.createElement('div', { className: 'flex gap-2' },
                React.createElement('input', {
                  type: 'text',
                  value: youtubeUrl,
                  onChange: (e) => setYoutubeUrl(e.target.value),
                  placeholder: 'Paste YouTube URL...',
                  className: 'flex-1 bg-gray-700/50 text-white px-3 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500',
                  onKeyDown: (e) => e.key === 'Enter' && handleYoutubeDownload()
                }),
                React.createElement('button', {
                  onClick: handleYoutubeDownload,
                  disabled: !youtubeUrl.trim() || backendStatus?.status !== 'ok',
                  className: 'bg-orange-600 hover:bg-orange-700 disabled:bg-gray-600 disabled:cursor-not-allowed px-6 py-2 rounded-lg transition font-bold'
                }, 'Download')
              ),

              downloading.length > 0 && React.createElement('div', { className: 'space-y-2' },
                downloading.map(dl => 
                  React.createElement('div', { key: dl.id, className: 'bg-gray-700/50 rounded p-2' },
                    React.createElement('div', { className: 'flex justify-between text-xs mb-1' },
                      React.createElement('span', { className: 'truncate' }, dl.title || 'Downloading...'),
                      React.createElement('span', null, `${Math.round(dl.progress || 0)}%`)
                    ),
                    React.createElement('div', { className: 'h-2 bg-gray-600 rounded overflow-hidden' },
                      React.createElement('div', {
                        className: 'h-full bg-orange-500 transition-all',
                        style: { width: `${dl.progress || 0}%` }
                      })
                    )
                  )
                )
              ),

              React.createElement('div', { className: 'pt-3 border-t border-gray-700' },
                React.createElement('button', {
                  onClick: () => setShowYoutubePanel(!showYoutubePanel),
                  className: 'text-sm text-blue-400 hover:text-blue-300 underline'
                }, showYoutubePanel ? 'â†‘ Hide YouTube Search' : 'ðŸ” Search YouTube')
              ),

              showYoutubePanel && React.createElement('div', { className: 'bg-gray-900/50 rounded-lg p-3 border border-blue-500/30' },
                React.createElement('p', { className: 'text-xs text-gray-400 mb-2' }, 'Search YouTube in new tab:'),
                React.createElement('input', {
                  type: 'text',
                  value: youtubeSearchQuery,
                  onChange: (e) => setYoutubeSearchQuery(e.target.value),
                  placeholder: 'e.g., fireworks display...',
                  className: 'w-full bg-gray-700/50 text-white px-3 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm mb-2',
                  onKeyDown: (e) => {
                    if (e.key === 'Enter' && youtubeSearchQuery.trim()) {
                      window.open(`https://www.youtube.com/results?search_query=${encodeURIComponent(youtubeSearchQuery)}`, '_blank');
                    }
                  }
                }),
                React.createElement('button', {
                  onClick: () => {
                    if (youtubeSearchQuery.trim()) {
                      window.open(`https://www.youtube.com/results?search_query=${encodeURIComponent(youtubeSearchQuery)}`, '_blank');
                    }
                  },
                  className: 'w-full bg-blue-600 hover:bg-blue-700 px-3 py-2 rounded-lg text-sm transition'
                }, 'ðŸ” Search on YouTube')
              )
            )
          )
        ),

        // Add from Library Dialog
        showLibraryAdd && React.createElement('div', { className: 'fixed inset-0 bg-black/50 flex items-center justify-center z-50' },
          React.createElement('div', { className: 'bg-gray-800 rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto' },
            React.createElement('div', { className: 'flex items-center justify-between mb-4' },
              React.createElement('h3', { className: 'text-xl font-bold' }, 'ðŸ“š Add from Library'),
              React.createElement('button', {
                onClick: () => setShowLibraryAdd(false),
                className: 'bg-gray-600 hover:bg-gray-500 px-3 py-1 rounded'
              }, 'âœ•')
            ),
            downloadedVideos.size === 0 
              ? React.createElement('p', { className: 'text-gray-500 text-center py-8' }, 'No videos in library')
              : React.createElement('div', { className: 'space-y-2' },
                  Array.from(downloadedVideos.values()).map(video =>
                    React.createElement('div', {
                      key: video.filename,
                      className: 'bg-gray-700 rounded p-3 hover:bg-gray-600 transition cursor-pointer',
                      onClick: () => {
                        onAddFromLibrary(video);
                        setShowLibraryAdd(false);
                      }
                    },
                      React.createElement('div', { className: 'font-medium text-sm' }, video.title),
                      React.createElement('div', { className: 'text-xs text-gray-400' }, video.filename),
                      (video.defaultTrimStart > 0 || video.defaultTrimEnd > 0) && React.createElement('div', { className: 'text-xs text-yellow-400 mt-1' },
                        `Default trim: ${video.defaultTrimStart.toFixed(1)}s - ${video.defaultTrimEnd.toFixed(1)}s`
                      )
                    )
                  )
                )
          )
        ),

        // Video Grid Section
        React.createElement('div', { className: 'mb-4' },
          React.createElement('div', { className: 'flex flex-col md:flex-row items-start md:items-center justify-between mb-2 gap-2' },
            React.createElement('h2', { className: 'font-semibold text-gray-300 text-sm md:text-base' }, 
              `Video Grid (${activeVideos.length} playing / ${videos.length} total)`
            ),
            React.createElement('div', { className: 'flex items-center gap-2 md:gap-3' },
              React.createElement('span', { className: 'text-xs text-gray-400 hidden sm:inline' }, 'Grid Height:'),
              React.createElement('input', {
                type: 'range',
                min: '150',
                max: '800',
                step: '50',
                value: gridHeight,
                onChange: (e) => {
                  const height = parseInt(e.target.value);
                  setGridHeight(height);
                  localStorage.setItem('fwp_gridHeight', height);
                },
                className: 'w-24 md:w-32'
              }),
              React.createElement('span', { className: 'text-xs text-gray-300 w-12 md:w-16' }, `${gridHeight}px`)
            )
          ),
          
          React.createElement('div', { 
            className: 'gap-2 bg-gray-900 rounded-lg p-2 overflow-auto',
            style: { 
              height: `${gridHeight}px`,
              display: 'grid',
              gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))',
              alignContent: 'start'
            }
          },
          videos.length === 0
            ? React.createElement('div', { className: 'col-span-full flex items-center justify-center border-2 border-dashed border-gray-600 rounded-lg' },
                React.createElement('div', { className: 'text-center text-gray-400' },
                  React.createElement('p', { className: 'text-lg mb-2' }, 'No videos loaded'),
                  React.createElement('p', { className: 'text-sm' }, 'Use "Add from Library" to add videos to your timeline')
                )
              )
            : filteredVideos.map(video => {
                const trimStart = video.trimStart || 0;
                const trimEnd = video.trimEnd || 0;
                const videoTime = masterTime - video.offset;
                const trimmedDuration = (video.duration || 0) - trimStart - trimEnd;
                const isActive = video.duration && video.duration > 0 && videoTime >= 0 && videoTime <= trimmedDuration;
                
                return React.createElement('div', {
                  key: video.id,
                  className: 'relative bg-black rounded-lg overflow-hidden border-2 transition-colors flex items-center justify-center',
                  style: { 
                    borderColor: isActive ? video.color : '#374151',
                    aspectRatio: '16/9'
                  }
                },
                  video.url 
                    ? React.createElement('video', {
                        ref: el => {
                          if (el) videoRefs.current[video.id] = el;
                        },
                        src: video.url,
                        className: 'max-w-full max-h-full object-cover',
                        style: {
                          clipPath: `inset(${video.cropY || 0}% ${100 - (video.cropX || 0) - (video.cropWidth || 100)}% ${100 - (video.cropY || 0) - (video.cropHeight || 100)}% ${video.cropX || 0}%)`
                        },
                        onLoadedMetadata: (e) => {
                          if (e.target.duration) {
                            handleVideoLoaded(video.id, e.target.duration);
                          }
                        },
                        onError: (e) => {
                          console.error(`Failed to load video ${video.name}:`, video.url, e);
                        },
                        crossOrigin: 'anonymous',
                        preload: 'metadata'
                      })
                    : React.createElement('div', { 
                        className: 'flex items-center justify-center h-full text-gray-500 text-sm' 
                      }, 'No video URL'),
                  React.createElement('div', {
                    className: 'absolute top-2 left-2 px-2 py-1 rounded text-sm font-medium max-w-[60%] truncate',
                    style: { backgroundColor: video.color }
                  }, video.name),
                  React.createElement('button', {
                    onClick: () => removeVideo(video.id),
                    className: 'absolute top-2 right-2 bg-red-600 hover:bg-red-700 w-6 h-6 rounded flex items-center justify-center text-sm'
                  }, 'Ã—'),
                  React.createElement('div', { className: 'absolute bottom-2 left-2 right-2 bg-black/80 px-2 py-1 rounded space-y-1' },
                    React.createElement('div', { className: 'flex items-center gap-2' },
                      React.createElement('span', { className: 'text-xs' }, 'Start:'),
                      React.createElement('input', {
                        type: 'number',
                        value: video.offset.toFixed(1),
                        onChange: (e) => updateOffset(video.id, e.target.value),
                        className: 'w-16 md:w-14 bg-gray-800 text-white text-sm md:text-xs px-2 md:px-1 py-2 md:py-0.5 rounded',
                        step: '0.1',
                        min: '0'
                      }),
                      React.createElement('span', { className: 'text-xs text-gray-400' }, 's')
                    ),
                    React.createElement('div', { className: 'flex items-center gap-1' },
                      React.createElement('span', { className: 'text-xs' }, 'Trim:'),
                      React.createElement('input', {
                        type: 'number',
                        value: trimStart.toFixed(1),
                        onChange: (e) => updateTrimStart(video.id, e.target.value),
                        className: 'w-14 md:w-12 bg-gray-800 text-white text-sm md:text-xs px-2 md:px-1 py-2 md:py-0.5 rounded',
                        step: '0.1',
                        min: '0'
                      }),
                      React.createElement('span', { className: 'text-xs text-gray-400' }, 'â†”'),
                      React.createElement('input', {
                        type: 'number',
                        value: trimEnd.toFixed(1),
                        onChange: (e) => updateTrimEnd(video.id, e.target.value),
                        className: 'w-14 md:w-12 bg-gray-800 text-white text-sm md:text-xs px-2 md:px-1 py-2 md:py-0.5 rounded',
                        step: '0.1',
                        min: '0'
                      }),
                      React.createElement('span', { className: 'text-xs text-gray-400' }, 's'),
                      React.createElement('span', { className: 'text-xs text-gray-500 ml-auto' }, 
                        `${(trimmedDuration || 0).toFixed(1)}s`)
                    )
                  )
                );
              })
          )
        ),

        // Transport Controls
        React.createElement('div', { className: 'bg-gray-800 rounded-lg p-4 mb-4' },
          React.createElement('div', { className: 'flex items-center justify-center gap-4 mb-4' },
            React.createElement('button', {
              onClick: () => setMasterTime(0),
              className: 'bg-gray-700 hover:bg-gray-600 px-3 py-3 md:py-2 rounded text-base md:text-sm'
            }, 'â® Reset'),
            React.createElement('button', {
              onClick: () => setMasterTime(prev => Math.max(0, prev - 1)),
              className: 'bg-gray-700 hover:bg-gray-600 px-3 py-3 md:py-2 rounded text-base md:text-sm'
            }, '-1s'),
            React.createElement('button', {
              onClick: () => setIsPlaying(!isPlaying),
              className: `px-6 py-3 md:py-2 rounded font-bold text-base md:text-sm ${isPlaying ? 'bg-red-600 hover:bg-red-700' : 'bg-green-600 hover:bg-green-700'}`
            }, isPlaying ? 'â¸ Pause' : 'â–¶ Play'),
            React.createElement('button', {
              onClick: () => setMasterTime(prev => Math.min(totalDuration, prev + 1)),
              className: 'bg-gray-700 hover:bg-gray-600 px-3 py-3 md:py-2 rounded text-base md:text-sm'
            }, '+1s'),
            React.createElement('div', { className: 'text-xl font-mono ml-4' },
              `${formatTime(masterTime)} / ${formatTime(totalDuration)}`
            )
          ),
          React.createElement('input', {
            type: 'range',
            min: '0',
            max: totalDuration,
            step: '0.1',
            value: masterTime,
            onChange: (e) => setMasterTime(parseFloat(e.target.value)),
            className: 'w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-orange-500'
          })
        ),

        // Timeline
        React.createElement('div', { className: 'bg-gray-800 rounded-lg p-4' },
          React.createElement('div', { className: 'flex items-center justify-between mb-2' },
            React.createElement('h2', { className: 'font-semibold' }, 'Timeline'),
            React.createElement('div', { className: 'flex items-center gap-4' },
              React.createElement('div', { className: 'flex items-center gap-2' },
                React.createElement('span', { className: 'text-sm text-gray-400' }, 'Duration:'),
                React.createElement('input', {
                  type: 'number',
                  value: totalDuration,
                  onChange: (e) => setTotalDuration(Math.max(10, parseFloat(e.target.value) || 60)),
                  className: 'w-16 bg-gray-700 text-white text-sm px-2 py-1 rounded',
                  min: '10'
                }),
                React.createElement('span', { className: 'text-sm' }, 'sec')
              ),
              React.createElement('div', { className: 'flex items-center gap-2' },
                React.createElement('span', { className: 'text-sm text-gray-400 whitespace-nowrap' }, 'Zoom:'),
                React.createElement('input', {
                  type: 'range',
                  min: '0.5',
                  max: '4',
                  step: '0.1',
                  value: zoom,
                  onChange: (e) => setZoom(parseFloat(e.target.value)),
                  className: 'w-24 md:w-32'
                }),
                React.createElement('span', { className: 'text-sm text-gray-300 whitespace-nowrap w-10' }, `${zoom.toFixed(1)}x`)
              )
            )
          ),
          React.createElement('div', { className: 'relative h-6 mb-1 overflow-hidden' },
            Array.from({ length: Math.ceil(totalDuration / 5) + 1 }, (_, i) =>
              React.createElement('div', {
                key: i,
                className: 'absolute text-xs text-gray-500',
                style: { left: `${(i * 5 / totalDuration) * 100 * zoom}%` }
              }, `${i * 5}s`)
            )
          ),
          React.createElement('div', {
            ref: timelineRef,
            className: 'relative bg-gray-900 rounded overflow-x-auto cursor-pointer touch-pan-x',
            style: { minHeight: Math.max(100, videos.length * 50 + 20) },
            onClick: handleTimelineClick,
            onTouchStart: (e) => {
              if (!draggingId) {
                handleTimelineClick(e);
              }
            }
          },
            React.createElement('div', {
              className: 'absolute top-0 bottom-0 w-0.5 bg-red-500 z-20 pointer-events-none',
              style: { left: `${(masterTime / totalDuration) * 100 * zoom}%` }
            },
              React.createElement('div', {
                className: 'absolute -top-1 -left-2 w-0 h-0 border-l-4 border-r-4 border-t-8 border-transparent border-t-red-500'
              })
            ),
            videos.map((video, index) => {
              const trimStart = video.trimStart || 0;
              const trimEnd = video.trimEnd || 0;
              const trimmedDuration = (video.duration || 0) - trimStart - trimEnd;
              
              return React.createElement('div', {
                key: video.id,
                className: 'absolute h-10 md:h-8 rounded cursor-move flex items-center px-2 text-xs font-medium overflow-hidden whitespace-nowrap transition-shadow hover:shadow-lg no-select touch-none',
                style: {
                  top: index * 50 + 10,
                  left: `${(video.offset / totalDuration) * 100 * zoom}%`,
                  width: `${(trimmedDuration / totalDuration) * 100 * zoom}%`,
                  backgroundColor: video.color,
                  minWidth: '60px',
                  touchAction: 'none'
                },
                onMouseDown: (e) => handleTimelineMouseDown(e, video.id),
                onTouchStart: (e) => handleTimelineMouseDown(e, video.id)
              }, `${video.name} (${trimmedDuration.toFixed(1)}s)`);
            })
          ),
          React.createElement('p', { className: 'text-xs text-gray-500 mt-2' },
            'Drag clips to adjust timing â€¢ Click timeline to seek'
          )
        ),

        // Cue Sheet
        videos.length > 0 && React.createElement('div', { className: 'mt-4 bg-gray-800 rounded-lg p-4' },
          React.createElement('h3', { className: 'font-semibold mb-2' }, 'Show Timing Cue Sheet'),
          React.createElement('div', { className: 'grid gap-1 text-sm font-mono' },
            [...videos]
              .sort((a, b) => a.offset - b.offset)
              .map(video => {
                const trimStart = video.trimStart || 0;
                const trimEnd = video.trimEnd || 0;
                const trimmedDuration = (video.duration || 0) - trimStart - trimEnd;
                return React.createElement('div', { key: video.id, className: 'flex gap-2' },
                  React.createElement('span', { style: { color: video.color } }, 'â—'),
                  React.createElement('span', { className: 'text-gray-400 w-16' }, formatTime(video.offset)),
                  React.createElement('span', null, video.name),
                  React.createElement('span', { className: 'text-gray-500' }, `(${(trimmedDuration || 0).toFixed(1)}s)`)
                );
              })
          )
        )
      );
      } catch (err) {
        console.error('Error rendering ShowEditor:', err);
        return React.createElement('div', { className: 'min-h-screen bg-gray-900 text-white p-4' },
          React.createElement('h1', { className: 'text-red-500 text-xl mb-4' }, 'Error in Show Editor'),
          React.createElement('pre', { className: 'bg-gray-800 p-4 rounded overflow-auto' }, 
            err.message + '\n' + err.stack
          )
        );
      }
    };

    // ======================
    // Main App Component
    // ======================
    const FireworksPlanner = () => {
      // Authentication state
      const [authenticated, setAuthenticated] = React.useState(false);
      const [currentUser, setCurrentUser] = React.useState(null);
      const [checkingAuth, setCheckingAuth] = React.useState(true);
      
      const [currentView, setCurrentView] = React.useState('dashboard'); // 'dashboard', 'library', 'editor'
      const [currentShowName, setCurrentShowName] = React.useState(null);
      
      const [videos, setVideos] = React.useState([]);
      const [downloadedVideos, setDownloadedVideos] = React.useState(new Map());
      const [isPlaying, setIsPlaying] = React.useState(false);
      const [masterTime, setMasterTime] = React.useState(0);
      const [totalDuration, setTotalDuration] = React.useState(60);
      const [zoom, setZoom] = React.useState(1);
      const [draggingId, setDraggingId] = React.useState(null);
      const [dragStartX, setDragStartX] = React.useState(0);
      const [dragStartOffset, setDragStartOffset] = React.useState(0);
      
      const [savedSessions, setSavedSessions] = React.useState([]);
      const [gridHeight, setGridHeight] = React.useState(400);
      const [toasts, setToasts] = React.useState([]);
      
      const videoRefs = React.useRef({});
      const timelineRef = React.useRef(null);
      const animationRef = React.useRef(null);
      const lastTimeRef = React.useRef(Date.now());

      const showToast = (message, type = 'info') => {
        const id = Date.now();
        setToasts(prev => [...prev, { id, message, type }]);
        setTimeout(() => {
          setToasts(prev => prev.filter(t => t.id !== id));
        }, 3000);
      };

      // Check authentication on mount
      React.useEffect(() => {
        checkAuth();
      }, []);

      // Load data when authenticated
      React.useEffect(() => {
        if (authenticated) {
          loadSessionsList();
          loadAvailableVideos();
          
          const savedGridHeight = localStorage.getItem('fwp_gridHeight');
          if (savedGridHeight) {
            setGridHeight(parseInt(savedGridHeight));
          }
        }
      }, [authenticated]);

      // Reload library when returning to dashboard
      React.useEffect(() => {
        if (authenticated && currentView === 'dashboard') {
          loadAvailableVideos();
        }
      }, [currentView, authenticated]);

      const checkAuth = async () => {
        try {
          const res = await fetch(`${API_BASE}/api/auth/me`, {
            credentials: 'include'
          });
          const data = await res.json();
          
          if (data.authenticated && data.user) {
            setAuthenticated(true);
            setCurrentUser(data.user);
            // Clean up OAuth redirect URL if present
            const hash = window.location.hash;
            if (hash.includes('#/dashboard') || hash.includes('error=')) {
              window.history.replaceState({}, document.title, window.location.pathname + '#/dashboard');
            }
          } else {
            setAuthenticated(false);
            setCurrentUser(null);
          }
        } catch (err) {
          console.error('Auth check failed:', err);
          setAuthenticated(false);
        } finally {
          setCheckingAuth(false);
        }
      };

      const handleLogin = (user) => {
        setAuthenticated(true);
        setCurrentUser(user);
        showToast(`Welcome, ${user.username}!`, 'success');
      };

      const handleLogout = async () => {
        try {
          await fetch(`${API_BASE}/api/auth/logout`, {
            method: 'POST',
            credentials: 'include'
          });
        } catch (err) {
          console.error('Logout error:', err);
        }
        
        setAuthenticated(false);
        setCurrentUser(null);
        setSavedSessions([]);
        setDownloadedVideos(new Map());
        setVideos([]);
        setCurrentView('dashboard');
        showToast('Logged out', 'info');
      };

      const loadSessionsList = async () => {
        // Only load from server if authenticated
        if (!authenticated) {
          // Not authenticated - use localStorage (though user shouldn't see this)
          const sessions = JSON.parse(localStorage.getItem('fwp_sessions') || '[]');
          setSavedSessions(sessions);
          return;
        }
        
        try {
          const res = await fetch(`${API_BASE}/api/shows`, {
            credentials: 'include'
          });
          if (res.ok) {
            const sessions = await res.json();
            setSavedSessions(sessions.map(s => ({
              name: s.name,
              timestamp: s.timestamp,
              totalDuration: s.data.totalDuration || 60,
              zoom: s.data.zoom || 1,
              videos: s.data.videos || []
            })));
          } else {
            // Server error - show empty (don't fallback to localStorage for authenticated users)
            console.error('Failed to load shows from server:', res.status);
            setSavedSessions([]);
          }
        } catch (err) {
          console.error('Failed to load shows from server:', err);
          // Network error - show empty (don't fallback to localStorage for authenticated users)
          setSavedSessions([]);
        }
      };

      const loadAvailableVideos = async () => {
        // Only load from server if authenticated
        const videoMap = new Map();
        
        // First, load videos from IndexedDB (client-side downloads)
        try {
          const db = await openVideoDB();
          const transaction = db.transaction([STORE_NAME], 'readonly');
          const store = transaction.objectStore(STORE_NAME);
          const request = store.getAll();
          
          await new Promise((resolve, reject) => {
            request.onsuccess = () => {
              request.result.forEach(item => {
                const videoId = item.videoId;
                const filename = `${videoId}.mp4`;
                const localUrl = URL.createObjectURL(item.blob);
                videoMap.set(filename, {
                  filename: filename,
                  title: item.title || `Video ${videoId}`,
                  url: localUrl,
                  sourceUrl: `https://www.youtube.com/watch?v=${videoId}`,
                  size: null,
                  duration: item.duration || null,
                  defaultTrimStart: 0,
                  defaultTrimEnd: 0,
                  defaultCropX: 0,
                  defaultCropY: 0,
                  defaultCropWidth: 100,
                  defaultCropHeight: 100,
                  localUrl: true
                });
              });
              resolve();
            };
            request.onerror = () => reject(request.error);
          });
        } catch (err) {
          console.warn('Failed to load videos from IndexedDB:', err);
        }
        
        // Also load from server if authenticated (for backward compatibility)
        if (authenticated) {
          try {
            const videosRes = await fetch(`${API_BASE}/api/videos`, {
              credentials: 'include'
            });
            if (videosRes.ok) {
              const serverVideos = await videosRes.json();
              
              // Load library metadata from server
              let serverLibrary = {};
              try {
                const libraryRes = await fetch(`${API_BASE}/api/library`, {
                  credentials: 'include'
                });
                if (libraryRes.ok) {
                  serverLibrary = await libraryRes.json();
                }
              } catch (e) {
                console.warn('Failed to load library from server:', e);
              }
              
              serverVideos.forEach(video => {
                // Only add if not already in map (IndexedDB takes precedence)
                if (!videoMap.has(video.filename)) {
                  const savedData = serverLibrary[video.filename] || {};
                  videoMap.set(video.filename, {
                    filename: video.filename,
                    title: savedData.title || video.title || video.filename,
                    url: `${API_BASE}/videos/${video.filename}`,
                    sourceUrl: savedData.sourceUrl || null,
                    size: video.size,
                    duration: savedData.duration || null,
                    defaultTrimStart: savedData.defaultTrimStart || 0,
                    defaultTrimEnd: savedData.defaultTrimEnd || 0,
                    defaultCropX: savedData.defaultCropX || 0,
                    defaultCropY: savedData.defaultCropY || 0,
                    defaultCropWidth: savedData.defaultCropWidth || 100,
                    defaultCropHeight: savedData.defaultCropHeight || 100
                  });
                }
              });
            }
          } catch (err) {
            console.warn('Failed to load videos from server:', err);
          }
        }
        
        setDownloadedVideos(videoMap);
      };

      const saveLibraryMetadata = async (videos) => {
        const libraryData = {};
        videos.forEach((video, filename) => {
          libraryData[filename] = {
            title: video.title,
            sourceUrl: video.sourceUrl,
            duration: video.duration,
            defaultTrimStart: video.defaultTrimStart || 0,
            defaultTrimEnd: video.defaultTrimEnd || 0,
            defaultCropX: video.defaultCropX || 0,
            defaultCropY: video.defaultCropY || 0,
            defaultCropWidth: video.defaultCropWidth || 100,
            defaultCropHeight: video.defaultCropHeight || 100
          };
        });
        
        // Save to localStorage (fallback)
        localStorage.setItem('fwp_library', JSON.stringify(libraryData));
        
        // Sync to server
        if (authenticated) {
          try {
            for (const [filename, metadata] of Object.entries(libraryData)) {
              await fetch(`${API_BASE}/api/library`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ filename, metadata })
              });
            }
          } catch (err) {
            console.warn('Failed to sync library to server:', err);
          }
        }
      };

      const handleNewShow = () => {
        setCurrentShowName(null);
        setVideos([]);
        setMasterTime(0);
        setTotalDuration(60);
        setZoom(1);
        setIsPlaying(false);
        setCurrentView('editor');
      };

      const handleEditShow = async (showName) => {
        let session = null;
        
        // Try to load from server first
        if (authenticated) {
          try {
            const res = await fetch(`${API_BASE}/api/shows`, {
              credentials: 'include'
            });
            if (res.ok) {
              const shows = await res.json();
              const foundShow = shows.find(s => s.name === showName);
              if (foundShow) {
                session = {
                  name: foundShow.name,
                  timestamp: foundShow.timestamp,
                  totalDuration: foundShow.data.totalDuration || 60,
                  zoom: foundShow.data.zoom || 1,
                  videos: foundShow.data.videos || []
                };
              }
            }
          } catch (err) {
            console.warn('Failed to load show from server:', err);
          }
        }
        
        // Fallback to localStorage
        if (!session) {
          const sessions = JSON.parse(localStorage.getItem('fwp_sessions') || '[]');
          session = sessions.find(s => s.name === showName);
        }
        
        if (!session) {
          showToast('Session not found', 'error');
          return;
        }

        videos.forEach(v => {
          if (v.url && v.url.startsWith('blob:')) {
            URL.revokeObjectURL(v.url);
          }
        });

        // Restore video URLs from API_BASE if needed
        const restoredVideos = session.videos
          .filter(v => v.filename || v.url)
          .map(v => ({
            ...v,
            url: v.url || (v.filename ? `${API_BASE}/videos/${v.filename}` : null)
          }))
          .filter(v => v.url);

        setVideos(restoredVideos);
        setTotalDuration(session.totalDuration || 60);
        setZoom(session.zoom || 1);
        setMasterTime(0);
        setIsPlaying(false);
        setCurrentShowName(showName);
        setCurrentView('editor');
        showToast(`Loaded "${showName}"`, 'success');
      };

      const handleBackToDashboard = () => {
        if (currentShowName && videos.length > 0) {
          saveShow(currentShowName, true);
        }
        setCurrentView('dashboard');
        setIsPlaying(false);
        loadSessionsList();
      };

      const handleGoToLibrary = () => {
        setCurrentView('library');
        loadAvailableVideos();
      };

      const handleBackFromLibrary = () => {
        setCurrentView('dashboard');
        loadAvailableVideos();
      };

      const handleDeleteShow = async (name) => {
        // Delete from localStorage
        const sessions = JSON.parse(localStorage.getItem('fwp_sessions') || '[]');
        const filtered = sessions.filter(s => s.name !== name);
        localStorage.setItem('fwp_sessions', JSON.stringify(filtered));
        
        // Delete from server
        if (authenticated) {
          try {
            await fetch(`${API_BASE}/api/shows/${encodeURIComponent(name)}`, {
              method: 'DELETE',
              credentials: 'include'
            });
          } catch (err) {
            console.warn('Failed to delete show from server:', err);
          }
        }
        
        loadSessionsList();
        showToast(`Deleted show "${name}"`, 'success');
      };

      const handleDownloadComplete = async (dl) => {
        // Check if this is a server-side download (has filename but no localUrl flag)
        const isServerSideDownload = dl.filename && !dl.localUrl && !dl.videoId;
        
        if (isServerSideDownload) {
          // Server-side download: Refresh library from server
          console.log('[Download Complete] Server-side download detected, refreshing library...');
          await loadAvailableVideos();
          showToast(`Downloaded: ${dl.title || dl.filename || 'Video'}`, 'success');
          return;
        }
        
        // Client-side download: Add video to downloadedVideos map (IndexedDB)
        const videoId = dl.videoId || extractVideoId(dl.url) || dl.filename?.replace('.mp4', '');
        if (videoId) {
          const localUrl = dl.localUrl || await getVideoFromDB(videoId);
          if (localUrl) {
            const metadata = await getVideoMetadataFromDB(videoId);
            setDownloadedVideos(prev => {
              const newMap = new Map(prev);
              const filename = `${videoId}.mp4`;
              newMap.set(filename, {
                filename: filename,
                title: dl.title || metadata?.title || `Video ${videoId}`,
                url: localUrl,
                sourceUrl: dl.url || `https://www.youtube.com/watch?v=${videoId}`,
                size: null, // Size not available from IndexedDB
                duration: metadata?.duration || null,
                defaultTrimStart: 0,
                defaultTrimEnd: 0,
                defaultCropX: 0,
                defaultCropY: 0,
                defaultCropWidth: 100,
                defaultCropHeight: 100,
                localUrl: true // Flag to indicate it's from IndexedDB
              });
              saveLibraryMetadata(newMap);
              return newMap;
            });
          }
        }
        showToast(`Downloaded: ${dl.title || dl.filename || 'Video'}`, 'success');
      };

      const handleDeleteVideo = async (video) => {
        try {
          await fetch(`${API_BASE}/api/videos/${video.filename}`, {
            method: 'DELETE',
            credentials: 'include'
          });
          
          setDownloadedVideos(prev => {
            const newMap = new Map(prev);
            newMap.delete(video.filename);
            saveLibraryMetadata(newMap);
            return newMap;
          });

          setVideos(prev => prev.filter(v => v.filename !== video.filename));
          showToast(`"${video.title}" deleted`, 'success');
        } catch (err) {
          showToast('Failed to delete video: ' + err.message, 'error');
        }
      };

      const handleSaveVideoSettings = async (filename, updates) => {
        setDownloadedVideos(prev => {
          const newMap = new Map(prev);
          const existing = newMap.get(filename);
          if (existing) {
            const updated = { ...existing, ...updates };
            newMap.set(filename, updated);
            
            // Prepare metadata
            const metadata = {
              title: updated.title,
              sourceUrl: updated.sourceUrl,
              duration: updated.duration,
              defaultTrimStart: updated.defaultTrimStart || 0,
              defaultTrimEnd: updated.defaultTrimEnd || 0,
              defaultCropX: updated.defaultCropX || 0,
              defaultCropY: updated.defaultCropY || 0,
              defaultCropWidth: updated.defaultCropWidth || 100,
              defaultCropHeight: updated.defaultCropHeight || 100
            };
            
            // Save this specific video's metadata to server
            if (authenticated) {
              fetch(`${API_BASE}/api/library`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ filename, metadata })
              })
              .then(res => {
                if (!res.ok) {
                  return res.json().then(err => {
                    throw new Error(err.error || `Server error: ${res.status}`);
                  });
                }
                return res.json();
              })
              .then(data => {
                if (data.success) {
                  console.log('Video settings saved successfully');
                }
              })
              .catch(err => {
                console.error('Failed to save video settings:', err);
                showToast(`Failed to save settings: ${err.message}`, 'error');
              });
            }
            
            // Also save to localStorage as backup
            const libraryData = JSON.parse(localStorage.getItem('fwp_library') || '{}');
            libraryData[filename] = metadata;
            localStorage.setItem('fwp_library', JSON.stringify(libraryData));
          }
          return newMap;
        });
        showToast('Video settings saved', 'success');
      };

      const handleAddFromLibrary = (videoData) => {
        const newInstance = {
          id: `${videoData.filename}-${Date.now()}`,
          name: videoData.title || videoData.filename,
          filename: videoData.filename,
          url: videoData.url,
          sourceUrl: videoData.sourceUrl,
          offset: 0,
          duration: 0,
          volume: 1.0,
          trimStart: videoData.defaultTrimStart || 0,
          trimEnd: videoData.defaultTrimEnd || 0,
          cropX: videoData.defaultCropX || 0,
          cropY: videoData.defaultCropY || 0,
          cropWidth: videoData.defaultCropWidth || 100,
          cropHeight: videoData.defaultCropHeight || 100,
          color: `hsl(${videos.length * 60}, 70%, 50%)`
        };
        setVideos(prev => [...prev, newInstance]);
      };

      const saveShow = async (name, silent = false) => {
        if (!name || !name.trim()) {
          if (!silent) showToast('Please enter a show name', 'warning');
          return;
        }

        const sessionData = {
          totalDuration,
          zoom,
          videos: videos.map(v => ({
            id: v.id,
            name: v.name,
            filename: v.filename,
            url: v.url.startsWith('blob:') ? null : v.url,
            offset: v.offset,
            duration: v.duration,
            volume: v.volume,
            trimStart: v.trimStart || 0,
            trimEnd: v.trimEnd || 0,
            cropX: v.cropX || 0,
            cropY: v.cropY || 0,
            cropWidth: v.cropWidth || 100,
            cropHeight: v.cropHeight || 100,
            color: v.color
          }))
        };

        // Save to localStorage (fallback)
        const session = {
          name: name.trim(),
          timestamp: new Date().toISOString(),
          ...sessionData
        };
        const sessions = JSON.parse(localStorage.getItem('fwp_sessions') || '[]');
        const existingIndex = sessions.findIndex(s => s.name === name.trim());
        
        if (existingIndex >= 0) {
          sessions[existingIndex] = session;
        } else {
          sessions.push(session);
        }

        localStorage.setItem('fwp_sessions', JSON.stringify(sessions));
        localStorage.setItem('fwp_lastSession', name.trim());

        // Sync to server
        if (authenticated) {
          try {
            await fetch(`${API_BASE}/api/shows`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              credentials: 'include',
              body: JSON.stringify({
                name: name.trim(),
                data: sessionData
              })
            });
          } catch (err) {
            console.warn('Failed to sync show to server:', err);
          }
        }

        loadSessionsList();
        setCurrentShowName(name.trim());
        if (!silent) {
          showToast(`Show "${name.trim()}" saved!`, 'success');
        }
      };

      // Auto-save when editing
      React.useEffect(() => {
        if (currentView === 'editor' && currentShowName && videos.length > 0) {
          const interval = setInterval(() => {
            saveShow(currentShowName, true);
          }, 10000);
          return () => clearInterval(interval);
        }
      }, [currentView, currentShowName, videos, totalDuration, zoom]);

      // Video playback sync
      React.useEffect(() => {
        if (isPlaying) {
          lastTimeRef.current = Date.now();
          
          const tick = () => {
            const now = Date.now();
            const delta = (now - lastTimeRef.current) / 1000;
            lastTimeRef.current = now;
            
            setMasterTime(prev => {
              const next = prev + delta;
              if (next >= totalDuration) {
                setIsPlaying(false);
                return 0;
              }
              return next;
            });
            
            animationRef.current = requestAnimationFrame(tick);
          };
          
          animationRef.current = requestAnimationFrame(tick);
        } else if (animationRef.current) {
          cancelAnimationFrame(animationRef.current);
        }
        
        return () => {
          if (animationRef.current) cancelAnimationFrame(animationRef.current);
        };
      }, [isPlaying, totalDuration]);

      React.useEffect(() => {
        videos.forEach(video => {
          const videoEl = videoRefs.current[video.id];
          if (!videoEl) return;
          
          videoEl.volume = video.volume || 1.0;
          
          const trimStart = video.trimStart || 0;
          const trimEnd = video.trimEnd || 0;
          const videoTime = masterTime - video.offset;
          const trimmedDuration = video.duration - trimStart - trimEnd;
          
          if (videoTime >= 0 && videoTime <= trimmedDuration) {
            const actualVideoTime = videoTime + trimStart;
            
            if (Math.abs(videoEl.currentTime - actualVideoTime) > 0.3) {
              videoEl.currentTime = actualVideoTime;
            }
            if (isPlaying && videoEl.paused) {
              videoEl.play().catch(() => {});
            } else if (!isPlaying && !videoEl.paused) {
              videoEl.pause();
            }
          } else {
            if (!videoEl.paused) videoEl.pause();
            if (videoTime < 0) videoEl.currentTime = trimStart;
          }
        });
      }, [masterTime, videos, isPlaying]);

      // Show loading while checking auth
      if (checkingAuth) {
        return React.createElement('div', { 
          className: 'min-h-screen bg-gray-900 text-white flex items-center justify-center' 
        },
          React.createElement('div', { className: 'text-center' },
            React.createElement('div', { className: 'text-4xl mb-4' }, 'ðŸŽ†'),
            React.createElement('p', { className: 'text-gray-400' }, 'Loading...')
          )
        );
      }

      // Show login if not authenticated
      if (!authenticated) {
        return React.createElement(LoginView, { onLogin: handleLogin });
      }

      return React.createElement('div', null,
        currentView === 'dashboard' 
          ? React.createElement(Dashboard, {
              onEditShow: handleEditShow,
              onNewShow: handleNewShow,
              onGoToLibrary: handleGoToLibrary,
              savedSessions,
              onDeleteShow: handleDeleteShow,
              downloadedVideos,
              onDownloadComplete: handleDownloadComplete,
              currentUser,
              onLogout: handleLogout
            })
          : currentView === 'library'
          ? React.createElement(LibraryView, {
              downloadedVideos,
              setDownloadedVideos,
              onBack: handleBackFromLibrary,
              onDeleteVideo: handleDeleteVideo,
              onSaveVideoSettings: handleSaveVideoSettings,
              onDownloadComplete: handleDownloadComplete
            })
          : React.createElement(ShowEditor, {
              showName: currentShowName,
              videos,
              setVideos,
              downloadedVideos,
              isPlaying,
              setIsPlaying,
              masterTime,
              setMasterTime,
              totalDuration,
              setTotalDuration,
              zoom,
              setZoom,
              draggingId,
              setDraggingId,
              dragStartX,
              setDragStartX,
              dragStartOffset,
              setDragStartOffset,
              gridHeight,
              setGridHeight,
              videoRefs,
              timelineRef,
              onSave: saveShow,
              onBack: handleBackToDashboard,
              onAddFromLibrary: handleAddFromLibrary,
              onDownloadComplete: handleDownloadComplete
            }),

        // Toast Notifications
        React.createElement('div', {
          className: 'fixed top-4 right-4 z-50 flex flex-col gap-2',
          style: { maxWidth: '400px' }
        },
          toasts.map(toast => {
            const bgColor = toast.type === 'error' ? 'bg-red-600' : 
                           toast.type === 'success' ? 'bg-green-600' : 
                           toast.type === 'warning' ? 'bg-yellow-600' : 
                           'bg-blue-600';
            const icon = toast.type === 'error' ? 'âŒ' : 
                        toast.type === 'success' ? 'âœ…' : 
                        toast.type === 'warning' ? 'âš ï¸' : 
                        'â„¹ï¸';
            
            return React.createElement('div', {
              key: toast.id,
              className: `${bgColor} text-white px-4 py-3 rounded-lg shadow-lg flex items-start gap-2`
            },
              React.createElement('span', { className: 'text-lg' }, icon),
              React.createElement('span', { className: 'flex-1 text-sm' }, toast.message)
            );
          })
        )
      );
    };

    try {
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(FireworksPlanner));
    } catch (error) {
      console.error('Failed to render app:', error);
      document.getElementById('root').innerHTML = `
        <div style="padding: 20px; color: red;">
          <h1>Error Loading Application</h1>
          <p>${error.message}</p>
          <pre>${error.stack}</pre>
        </div>
      `;
    }
  </script>
</body>
</html>
